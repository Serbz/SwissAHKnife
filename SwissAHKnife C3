;#######################################################################################################################
;#######################################################################################################################
;
;   SECTION 1: SCRIPT INFO & HOTKEYS (v3 - Reorganized)
;
;#######################################################################################################################
;#######################################################################################################################

;  Usage:  (required AHK v1.1.31+)
;;;
;;;     Space - CHANGES THE KEY MODE !!! - Three modes, OSD, Window Management
;;;     
;;;     OSD MODE KEYS: (KeySet=1)
;;;         CAPSLOCK + 
;;;         F - Changes the Capslock + Left/Right Mouse button and C key modes (Markers, Magnifiers, Counters, Notes)
;;;         X - Creates a tick counter, offers options if active to change style, remove the counter, or change the tick count limit.
;;;         Z - Offers options for hiding, sticking cursor objects (messages/timers/etc) and nameplates
;;;         E - Sets either the Account Specific countdown timer start time or the same for the Global Timer.
;;;         W - Pauses/Unpauses the global timer
;;;         T - Creates or removes an account specific timer
;;;         Q - Creates or removes the Global Timer
;;;         3 - Either counts the account specific counter up, or clears it - These are attached to nameplates, if nameplates are hidden these are too.
;;;         Up, Down, Left, Right - Move the nameplates and attached displays on the runelite windows, these locations are saved.
;;;     
;;;     
;;;     WINDOW MANAGEMENT KEYS: (KeySet=2)
;;;         CAPSLOCK + 
;;;         G - Sets window to be focused one controller input, if set to windows shell (taskbar) it will be ignored
;;;         U - Toggles on/off the automatic window focus of runelite under the cursor
;;;         3 - Disable/enable a window under the cursor
;;;         Q - Set a window to be always ontop or not
;;;         R - Save RUNELITE window locations or move to saved runelite window locations
;;;         W - Bring window opacity down
;;;         E - Reset window opacity to 255 (opaque)
;;;           C - Toggles the window's border and title bar
;;;
;;;
;;;     GLOBAL KEYS
;;;         Capslock alone - Cycles through runelite window focus, priority on next account window if active else search for empty runelite (not logged in)
;;;         CAPSLOCK + 
;;;         D - Bring firefox/chrome into focus
;;;         Y - Reloads the script
;;;         B - Clears script settings, either all or all non-account settings    
;;;         N - Kills all runelite windows without warning
;;;         H - Kills the window, any window, even explorer, that is under the cursor without warning.
;(DISABLED) ;         A - Hides a window off screen, press again to bring it back
;;;         4 - Makes the window under the cursor bounce around the screen, Capslock+5 to stop all bouncing windows.
;;;         V - Toggles Debug OSD
;;;         
;;;

;;;     ***It should go without saying, this script does not break jagex ToS.***
;
; --- REFACTOR NOTES ---
;   This script was heavily refactored from its original state.
;   - All .log/.txt config files in SerbzOSD have been consolidated into a single 'config.ini' file.
;   - Removed dozens of unused global variables and remnants of old features.
;   - Renamed confusing variables (e.g., 'WaitJustOneFuckingSecond' -> 'g_ActionDelay').
;   - Created a helper function 'ShowOsdMessage(Text, Seconds)' to standardize OSD messages.
;   - Converted 'goto' labels for timer controls ('timerclear', 'SetTimer_Minutes') into functions.
;   - Cleaned up account discovery logic to read/write from the new config.ini.
;   - Reorganized sections for better logical flow (Timers, Functions, Labels are now grouped).
;

;#######################################################################################################################
;#######################################################################################################################
;
;   SECTION 2: INITIALIZATION & CONFIG (Auto-Execute)
;
;#######################################################################################################################
;#######################################################################################################################

; --- AHK Directives ---
#MaxThreads 999
#MaxThreadsPerHotkey 99
#MaxHotkeysPerInterval 999
#MaxThreadsBuffer On
#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
#SingleInstance Force
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
SetTitleMatchMode, 2 ; Match if the text appears anywhere in the window title
SetCapsLockState, off
SetCapsLockState, alwaysoff ; Critical for ensuring CapsLock acts as a modifier
StringCaseSense, off
DetectHiddenWindows, on
SetBatchLines, -1
CoordMode, Mouse, Screen

SetMouseDelay, 0
SetKeyDelay, 0
SetWinDelay, 0

; --- Font Installation Check (Original logic retained) ---
ifNotExist, C:\Windows\Fonts\OCR_A_STD_REGULAR.ttf
{
	;run, cmd.exe /c copy %A_ScriptDir%\OCR A Std Regular\OCR A Std Regular.ttf C:\Windows\Fonts\OCR_A_STD_REGULAR.ttf
	run, cmd.exe /c echo. REGEDIT4 >> %A_ScriptDir%\Fonts\Font.reg
	run, cmd.exe /c echo. \[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts\] >> %A_ScriptDir%\Fonts\Font.reg
	run, cmd.exe /c echo. "OCRAStd"="OCR_A_STD_REGULAR" >> %A_ScriptDir%\Fonts\Font.reg
	run, cmd.exe /c copy %A_ScriptDir%\Fonts\OCR_A_STD_REGULAR.ttf C:\Windows\Fonts\
	run, cmd.exe /c reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts" /v "OCRAStd (TrueType)" /t REG_SZ /d OCR_A_STD_REGULAR.ttf /f
	run, cmd.exe /c "HKLM\SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Fonts" /v "OCRAStd (TrueType)" /t REG_SZ /d OCR_A_STD_REGULAR.ttf /f
	sleep, 1000
	filedelete, %A_ScriptDir%\Fonts\Font.reg
	gosub caps_y ; Reload script to ensure font is loaded
}

; --- Configuration Paths ---
CS := A_ScriptDir "\SerbzOSD\"
ConfigPath := CS "config.ini"

ifNotExist, %CS%
{
	FileCreateDir, %CS%
}

IfExist, %A_ScriptDir%\favicon.ico
    Menu, Tray, Icon, %A_ScriptDir%\favicon.ico

; --- Controller Setup ---
ContName:=""
ControllerNumber:=0
controllerCheck() ; Changed from gosub
GetKeyState, cont_buttons, %ControllerNumber%JoyButtons
GetKeyState, cont_name, %ControllerNumber%JoyName
GetKeyState, cont_info, %ControllerNumber%JoyInfo
;controller_func(cont_buttons,cont_name,cont_info)


; --- MsbboxMove Init ---
MsgboxMove_String:=
SetTimer, MsgboxMove, 250
SetTimer, MsgboxMove, off


; --- Account Setup ---
Account := Object()
NumAccs:=0
Title:=
AccCounter:=0

; --- Variable Initialization ---
; --- Script State & Mode ---
KeySet:=1
MarkersNotesMagnifiers:="Markers"
WaitJustOneFuckingSecond:=2 ; Formerly g_ActionDelay
InitFinish:=0 ; Will be set to 1 at the end of auto-execute
ActiveToggle:=0
stopThreeGo:=0 ; Toggles if OSD elements follow the cursor
stopToggle:=0 ; Restored for Chaos Mode

; --- GUI, OSD & Messaging ---
GuiActiveArray:=Array()
GuiVarCounter:=0
GUI_Names:=0 ; Toggles nameplates
OSD_MOVE2:=0
OSD_MOVE:=0
3String= ; Primary OSD message string
5String:= ; Debug OSD message string
Global GuiOutlineID
Global MyText
asciichar := Chr(8226)
3Time:=0

; --- Timers (Global) ---
GlobalTimerMinutes:=
TimerIsRunning:=0
TimerIsPaused:=0
TimerResetWarning=0
TimerMouseT:=0
GUI2ActiveMouse:=0
TimerMgetX:=0
TimerMGetY:=0
TimeString:=""

; --- Timers (Account Specific) ---
AccountTimerCDownSec:=Array()
AccountTimerTotalSeconds:=Array()
AccountTimerTotalSecondsMin:=Array()
AccountTimerFloorTotalMin:=Array()
AccTimersIsOnTopArray:=Array()
TimerArrayMGetX:=0
TimerArrayMGetY:=0
AccTimerCDSec:=Array()
AccTimerTSec:=Array()
AccTimerTSecMin:=Array()
AccTimerFTMin:=Array()
ASTWindow:=Array()
AccTimerTimeStr=Object()
CapsTAccTimersCounter:=0
AccTimersTimerCounter:=0
AccTimerTimeStr2:=
AccTimerCDownSec:=
AccTimerMinFloor:=

; --- Audio ---
alcounter:=0
PlayVariable:=0
AltAlarmSound:=0
PlaySound:=0
randomvolasstimervar:=0

; --- Runelite & Account State ---
IsRunelite :=
RLUID:=
NameCheck2:=
AccountCheckName:=
NameDisable:=
AccColorWinChange=
A_TitleCheck:=
keyentercaps:=0
capsTitle=
lastmanual:=0
capsWinUMSwitch:=0
AccountGUIColor:=
RuneAcc_UID:=Object()
FoundX:=
FoundY:=

; --- General Counters ---
CounterVar:=0
counterkey:=0
count_type:=0
AccClear=0
CounterFuncArray:=Object()
GlobalMouseCounter:=0
WinCounterTVar:=0
cdvar:=0

; --- Tick Counter ---
TockTockTickText:=
TickTockTickTock:=0
tickHUD=0
initTick:=0
tickCounter:=0
TockTickText=
4ThreeX:=
4ThreeY:=
tickMonArray:=Array()
ThreeSinCosCounter:=0

; --- Markers & Notes ---
MarkerArrayY:=()
MarkerArrayX:=Array()
Note:=Array()
NoteSkipArray:=Array()
SkipCounterT:=
SkipCounter:=
MarkerCounter4:=
MarkerOutline:=
DotCounter:=0
offset1:=0
offset2:=0

; --- Magnifier ---
MouseFollowMag:=0
MouseFollowMagID:=0
MagGUID:=0
MagCounter:=0
xz := Array()
yz := Array()
Zy := Array()
Zx := Array()
ResX := Array()
ResY := Array()
x2 := Array()
y2 := Array()
hdd_frame := Array()
hdc_frame := Array()

; --- Macro Builder ---
mdelaycount:=50
xmcoordArray:=Array()
ordercoordArray:=Array()
ymcoordArray:=Array()

; --- Window Management (General) ---
DisableWindowToggle2:=0
DisableWindowToggle1=0
CountWindow:=0
OnTopArray:=Object()
WinDisable:=Array()
monstats:=
monH:=
monW:=

; --- Window Management (Chaos/Bounce Mode) ---
ChaosArray:=Array()
ChaosWindowGUIDArray:=Array()
ATimersIsOntop:=Array()
ChaosX:=Array()
ChaosY:=Array()
chaosDirection2:=Array()
chaosDirection:=Array()
CounterWinBack:=0
CounterWinBack2:=0
CounterWinBack3:=0 ; Restored for Chaos Mode
CounterWinBack4:=0 ; Restored for Chaos Mode
WinName:=Array()
WinNameNW:=Array()
WinNameNH:=Array()
WinNameNoXW:=Array()
WinNameNoXY:=Array()
WinBackTimerCounter:=0

; --- Window Management (Hide 'A' Mode) ---
WinName2:=Array()
WinNameNW2:=Array()
WinNameNH2:=Array()
WinNameNoXW2:=Array()
WinNameNoXY2:=Array()

; --- Controller ---
controller_out:=
O_controller_out:=
Controller_Window_Focus:=""

; --- Debugging ---
Debug:=0
DebugPriority:=0
DebugCycle:=0

; --- Misc/Unsorted ---
SaveWaitCounter:=0
wheelMouseClipval = a
T:=

; --- Get Monitor Info ---
mousegetpos, ThreeX, ThreeY
blockinput, on
mousemove, 100,100
MonArray:=monitorFunc()
sleep, 50
mousemove, ThreeX, ThreeY
blockinput, off


; --- Clipboard Variable Initialization (Reverted to clipboard.txt) ---
clipLimit:=0
clipCounter:=1
clipBoardA:=[]
clipBoardB:=[]
1paste := False ; <-- For clipboard function

ifExist %CS%clipboard.txt
{
    fileRead, clipboardPreSpl, %CS%clipboard.txt
    
    clipBoardB := strSplit(clipboardPreSpl, "|")
    
    for key, val in clipBoardB {
        if (val != "")
        {
            clipBoardA.insert(val)
        }
    }
    
    clipLimit := clipBoardA.count()
        
} else {
    FileAppend, , %CS%clipboard.txt
}
; --- End Reverted Clipboard Init ---

CurDisplayY:=0
CurDisplayX:=0
CurDisplayH := % MonArray[5]
CurDisplayW := % MonArray[6]
CurDisplayCY := % floor(CurDisplayH/2)
CurDisplayCX := % floor(CurDisplayW/2)
Gui3Color:=WHITE

; --- GUI Initialization ---
GuiNumber:=0
while (GuiNumber<5) {
GuiNumber++
OutlineBuilder(GuiNumber)
BuildGUI(GuiNumber)
Gui, %GuiNumber%: Hide
}

; --- Load Saved Settings from config.ini ---

; Load Accounts
IniRead, KnownAccounts, %ConfigPath%, Accounts, List, 
if (KnownAccounts != "ERROR" AND KnownAccounts != "")
{
    Loop, parse, KnownAccounts, |
    {
        if (A_LoopField != "")
        {
            Account.Insert(A_LoopField)
            NumAccs++
        }
    }
    AccountIndex := % Account.MaxIndex()-1
} else {
    AccountIndex := -1
}

AccDisable := Object()
    for key in Account {
        AccDisabled[key]:=0    
    }
AccDisabledIndex := % AccDisabled.MaxIndex()-1


IniRead, GUI_Names, %ConfigPath%, OSD, ShowNameplates, 1
IniRead, GlobalTimerMinutes, %ConfigPath%, Timers, GlobalMinutes, 0
if (GlobalTimerMinutes > 0) {
    GlobalTotalSeconds:=GlobalTimerMinutes*60
    GlobalSecondsDisplayInit:=GlobalTotalSeconds
} else {
    GlobalTotalSeconds:=
    GlobalTimerMinutes:=
    GlobalSecondsDisplayInit:=
}

IniRead, AccTimerTime, %ConfigPath%, Timers, AccTimerMinutes, 0
IniRead, tickDisplaySetting, %ConfigPath%, TickCounter, DisplaySetting, 1
if (tickDisplaySetting<1 or tickDisplaySetting>3 or !tickDisplaySetting) {
    tickDisplaySetting:=1
}

IniRead, tickLimit, %ConfigPath%, TickCounter, Limit, 0

IniRead, OSD_MOVE, %ConfigPath%, OSD, X_Offset, 0
IniRead, OSD_MOVE2, %ConfigPath%, OSD, Y_Offset, 0

IniRead, FFCH, %ConfigPath%, General, Browser,
if (FFCH = "" or FFCH = "ERROR") {
    MsgboxMove_String=Firefox or Chrome
    ChangeBtnNames:=1
    Btn1_Name=Firefox ; YES
    Btn2_Name=Chrome ; ELSE
    SetTimer, MsgboxMove, on
    MsgBox, 4, %MsgboxMove_String%, Choose your primary browser:
    IfMsgBox, YES 
        FFCH=Mozilla
    else 
        FFCH=Chrome
    IniWrite, %FFCH%, %ConfigPath%, General, Browser
}

IniRead, TimerIsPaused, %ConfigPath%, Timers, Paused, 0
IniRead, GlobalTimerMinR, %ConfigPath%, Timers, PausedMinutes, 0
IniRead, GlobalSecondDisplay, %ConfigPath%, Timers, PausedSeconds, 0

IniRead, ActiveToggle, %ConfigPath%, WindowMgmt, AutoFocus, 0
if (ActiveToggle = 1) {
    ActiveToggle:=0 ; Will be toggled back to 1 by the timer
    SetTimer, ActivateWinUM, on
} else {
    ActiveToggle:=1 ; Will be toggled back to 0 by the timer
    SetTimer, ActivateWinUM, off
}

IniRead, MouseMessages, %ConfigPath%, OSD, ShowMessages, 1

while (WaitJustOneFuckingSecond > 0)
     sleep,1
	 
; --- Start Timers ---
SetTimer, UpdateOSD, 100
SetTimer, UpdateOSD, on
SetTimer, UpdateOSD2, 1000
SetTimer, UpdateOSD2, off
SetTimer, SaveWait, 5000
SetTimer, SaveWait, off
SetTimer, AccTimers, 1000
SetTimer, AccTimers, off
SetTimer, Three, 27
SetTimer, Three, off
SetTimer, 1fuckingsecondtimer, 1000, on ; Renamed back
SetTimer, TimersCheck, 500
SetTimer, TimersCheck, on
SetTimer, ActivateWinUM, 0
SetTimer, Repaint, off
SetTimer, ChaosTimer, off

IniRead, Controller_Window_Focus, %ConfigPath%, Controller, FocusClass,
if (ControllerNumber > 0) {
	SetTimer, controller_timer, 300
	SetTimer, controller_timer, on
} else {
	SetTimer, controller_timer, off
}

; --- Finalize Initialization ---
SplashTextOff
ShowOsdMessage("Initialization Finish.", 1)
InitFinish:=1 
Return ; --- END OF AUTO-EXECUTE SECTION ---


;#######################################################################################################################
;#######################################################################################################################
;
;   SECTION 3: GLOBAL HOTKEYS
;
;#######################################################################################################################
;#######################################################################################################################

#If InitFinish=1 ; Ensure script is initialized before hotkeys are active

; --- Clipboard Hotkeys ---
~^c::
;send, ^c
sleep, 100
i:=""
ShowOsdMessage("Press C to save to clipboard", 2)
input, i, L1 M T1

if (i=="c") {
    clipBoardA.insert(clipboard)
    strStrstrstrstsrsrstsrtsr = added %clipboard%
    ShowOsdMessage("[" clipCounter "] - " strStrstrstrstsrsrstsrtsr " to clipboard array.", 2)
    sleep 20
    clipLimit:=0
    clipCounter++
    for key, val in clipBoardA
        clipLimit++
    if clipCounter < 1 
        clipCounter:=clipLimit
    if clipCounter > clipLimit
        clipCounter:=1
    
    ; Save to clipboard.txt (Reverted)
    ifExist, %CS%clipboard.txt
        fileDelete, %CS%clipboard.txt
    for key, val in clipBoardA
        fileAppend, %val%|, %CS%clipboard.txt
} else {
	send, % i
}
return

CTRL & Space::
keywait, Space
strStrtsrtsr := clipBoardA[clipCounter]
clipBoardA.remove(clipCounter)
		if clipCounter=0
		{
			ShowOsdMessage("There is nothing on the clipboard array.", 2)
			return
		} 
		else
		{		
		ShowOsdMessage("[" clipCounter "] - " strStrtsrtsr " removed from clipboard array.", 2)
        }
		clipLimit:=0
clipCounter--
for key, val in clipBoardA
    clipLimit++
		if clipCounter < 1 
			clipCounter:=clipLimit
		if clipCounter > clipLimit
			clipCounter:=1

    ; Save to clipboard.txt (Reverted)
    ifExist, %CS%clipboard.txt
        fileDelete, %CS%clipboard.txt
    for key, val in clipBoardA
        fileAppend, %val%|, %CS%clipboard.txt
return

capslock & k::
Capslock & WheelDown::
clipCounter--
		astring=clipboard
		alimit:=clipLimit
if (clipCounter < 1)
		clipCounter:=alimit
goto clipboardACont


capslock & I::
Capslock & WheelUp::
	clipCounter++
		alimit:=clipLimit
	if (clipCounter > alimit)
		clipCounter:=1 ;ahk starts with 1 not 0 which is odd anyway

clipboardACont:
		astring=clipboard
	if (alimit==0) {
			ShowOsdMessage("Nothing on " astring " array.", 1)
			return		
	}

		clipboard := clipBoardA[clipCounter]
		strestwaers := clipBoardA[clipCounter] 
		1paste := True
	ShowOsdMessage("[" clipCounter "/" alimit "] - " strestwaers, 1)
return

~^v::
ctrlV:
if (1paste==True)
	1paste:=False
return
; --- End Clipboard Hotkeys ---

capslock & esc::reload

CapsLock & d::
Keywait, d
WinGetClass, Class, A
If !InStr(Class, FFCH) {
WinGetActiveTitle, TitleP
WinActivate, %FFCH%
} else { 
WinSet, Bottom,, %FFCH%
WinActivate, %TitleP%
}
Return

capslock & p::FileAppend,, F:\Tools\_Scripts\!-AHK\!-Monitor_Manager\swap_mode.tmp

;--- Basic Window Movement ---
LALT & Left::
mult:=-3
goto mvwin2
LALT & right::
mult:=3
mvwin2:
wingetactivestats, title, w, h, x, y
xmult:=x+mult
winmove, A, , %xmult%, %y% 
return

LALT & Up::
mult:=-3
goto mvwin3
LALT & Down::
mult:=3
mvwin3:
wingetactivestats, title, w, h, x, y
ymult:=y+mult
winmove, A, , %x%, %ymult% 
return

;--- Precise Window Move/Resize ---
Capslock & del::
MouseGetPos, mx, my
wingetactivestats, title, w, h, x, y
inputbox, in, X and Y, Input X`, Y for window SIZE. `nWindow stats: W - %w% H - %h%,, 275, 175, mx, my
inys:=RegExReplace(in, "\d+\,\s?", "")
inxs:=RegExReplace(in, ",\s?\,\d+", "")
MouseGetPos, mx, my
wingetactivestats, title, w, h, x, y
inputbox, in, X and Y, Input X`, Y for window MOVE. `nWindow stats: W - %w% H - %h%,, 275, 175, mx, my
iny:=RegExReplace(in, "\d+\,\s?", "")
inx:=RegExReplace(in, ",\s?\,\d+", "")
winmove, A, , %inx%, %iny%, %inxs%, %inys%
return

;--- KeySet Mode Switch ---
Capslock & space::
if (KeySet=2) {
KeySet:=1
        ShowOsdMessage("On screen display", 2)
} else if (KeySet == 1) {
KeySet:=2
        ShowOsdMessage("Window Management", 2)
}
return

;--- Macro Builder Hotkeys ---

LCTRL & CAPSLOCK::
keywait CAPSLOCK
xmcoordArray := []
ordercoordArray := []
; ymcoordArray := []
        ShowOsdMessage("Macro cleared.", 2)
return

LALT & Q::
;for key, val in xmcoordArray
;{
;	clipboard = %clipboard% %key%`, %val%`,
;	
;}
;clipboard=%clipboard%`n
;for key, val in ymcoordArray
;{
;	clipboard = %clipboard% %key%`, %val%`,
;	
;}
if (xmcoordArray.MaxIndex() > 1) {
	mousegetpos, x, y
	x1v := % xmcoordArray[1]
	y1v := % ymcoordArray[1]
	xmcoordArray[1]:=x
	ymcoordArray[1]:=y
	x1v := x-x1v
	y1v := y-y1v

	for key, val in ymcoordArray
	{
		if (key > 1) {
			yv := val+y1v
			xv := % xmcoordArray[key]
			xv := xv+x1v
			xmcoordArray[key]:=xv
			ymcoordArray[key]:=yv
		}
	}
}

goto macroplay
;return
LCTRL & q::
gosub, markerPlaceOffsetSkip
	keywait Q
	counter := 0
	mousegetpos, x, y
	for each in xmcoordArray{
		counter+=1
	}
	xmcoordArray[counter+1]:=x
	ymcoordArray[counter+1]:=y
	ordercoordArray[counter+1]:=1
	ShowOsdMessage(x ", " y, 2)
return

LCTRL & E::
gosub, markerPlaceOffsetSkip
	keywait E
	counter := 0
	mousegetpos, x, y
	for each in xmcoordArray{
		counter+=1
	}
	xmcoordArray[counter+1]:=x
	ymcoordArray[counter+1]:=y
	ordercoordArray[counter+1]:=0
	ShowOsdMessage(x ", " y, 2)
return

LCTRL & R::
gosub, markerPlaceOffsetSkip
	keywait R
	counter := 0
	mousegetpos, x, y
	for each in xmcoordArray{
		counter+=1
	}
	xmcoordArray[counter+1]:=x
	ymcoordArray[counter+1]:=y
	ordercoordArray[counter+1]:=2
	ShowOsdMessage(x ", " y, 2)
return

LCTRL & w::
macroplay:
;;"
	sendinput, {w up}
	;;sendinput, {lctrl up}
	ShowOsdMessage("Playing macro...", 2)
	keywait w
	send, {ctrl up}{w up}
	sleep, 150
	mousegetpos, xx2, yy2
	blockinput, on
	sendinput, {w up}
	sendinput, {lctrl up}
	counter = 0
	for each, key in xmcoordArray {
	
		counter += 1
		xx := key
		yy := ymcoordArray[counter]
		oo := ordercoordArray[counter]
		;y := ymcoordArray[counter]
		ShowOsdMessage(xx ", " yy, 2)
		if (ordercoordArray[counter] == 3) {
			mousemove, %xx%, %yy%
		}
		if (ordercoordArray[counter] == 0) {
			mousemove, %xx%, %yy%
			send, {RButton}
			sleep, 250
		} else { 
			click, %xx%, %yy%
			
			sleep, mdelaycount
		}
		;gosub, markerPlaceOffsetSkip
	}
	blockinput, off	
	mousemove, xx2, yy2
	send, {return}
return

ctrl & numpadadd::
mdelaycount+=50
        ShowOsdMessage(mdelaycount, 2)
return
ctrl & numpadsub::
mdelaycount-=50
        ShowOsdMessage(mdelaycount, 2)
return

;--- Window Tiling Hotkeys ---
	#1::
	gosub, monstats
	sleep, 25
	mousegetpos, xmm, ymm
	wingetactivestats,t,t,t, x, y
	MouseMove, x+10, y+10
    WinMove A, , 0, 0, (monW/3), (monH/2)-6
	MouseMove, xmm, ymm
    return	
	
	#2::
	gosub, monstats
	sleep, 25
	mousegetpos, xmm, ymm
	wingetactivestats,t,t,t, x, y
	MouseMove, x+10, y+10
    WinMove A, , (monW/3), 0, (monW/3), (monH/2)-6
	MouseMove, xmm, ymm
    return
	
	#3::
	gosub, monstats
	sleep, 25
	mousegetpos, xmm, ymm
	wingetactivestats,t,t,t, x, y
	MouseMove, x+10, y+10
    WinMove A, , monW-(monW/3), 0, (monW/3), (monH/2)-6
	MouseMove, xmm, ymm
    return
	

	#q::
	gosub, monstats
	sleep, 25
	mousegetpos, xmm, ymm
	wingetactivestats,t,t,t, x, y
	MouseMove, x+10, y+10
    WinMove A, , 0, (monH/2)-6, (monW/3), (monH/2)-6
	MouseMove, xmm, ymm
    return	
	
	#w::
	gosub, monstats
	sleep, 25
	mousegetpos, xmm, ymm
	wingetactivestats,t,t,t, x, y
	MouseMove, x+10, y+10
    WinMove A, , (monW/3), (monH/2)-6, (monW/3), (monH/2)-6
	MouseMove, xmm, ymm
    return
	
	#e::
	gosub, monstats
	sleep, 25
	mousegetpos, xmm, ymm
	wingetactivestats,t,t,t, x, y
	MouseMove, x+10, y+10
    WinMove A, , monW-(monW/3), (monH/2)-6, (monW/3), (monH/2)-6
	MouseMove, xmm, ymm
    return
	
	#z::
	gosub, monstats
	sleep, 25
	mousegetpos, xmm, ymm
	wingetactivestats,t,t,t, x, y
	MouseMove, x+10, y+10
    WinMove A, , 0, 0, (monW/3), monH-12
	MouseMove, xmm, ymm
    return	
	
	#x::
	gosub, monstats
	sleep, 25
	mousegetpos, xmm, ymm
	wingetactivestats,t,t,t, x, y
	MouseMove, x+10, y+10
    WinMove A, , (monW/3), 0, (monW/3), monH-12
	MouseMove, xmm, ymm
    return
	
	#c::
	gosub, monstats
	sleep, 25
	mousegetpos, xmm, ymm
	wingetactivestats,t,t,t, x, y
	MouseMove, x+10, y+10
    WinMove A, , monW-(monW/3), 0, (monW/3), monH-12
	MouseMove, xmm, ymm
    return
	
	
	#a::
	gosub, monstats
	sleep, 25
	mousegetpos, xmm, ymm
	wingetactivestats,t,t,t, x, y
	MouseMove, x+10, y+10
	WinMove A, , 0, 0, (monW/2), monH-12
	MouseMove, xmm, ymm
    return
	
	#s::
	gosub, monstats
	sleep, 25
	mousegetpos, xmm, ymm
	wingetactivestats,t,t,t, x, y
	MouseMove, x+10, y+10
	WinMove A, , (monW/2), 0, (monW/2), monH-12
	MouseMove, xmm, ymm
    return
	

	monstats:
	monstats:=monitorFunc()
	monH:=monstats[5]-35
	monW:=monstats[6]
    return

;--- Misc Global Hotkeys ---

; --- Chaos/Bounce Mode (Caps+4, Caps+5) has been RESTORED ---
Capslock & 5::
CounterWinBack2:=0
CounterWinBack:=0
CounterWinBack3:=0
CounterWinBack4:=0
chaosBounce:=0
KeyCount:=0
setTimer, ChaosTimer, off
    for key, val in ChaosWindowGUIDArray { 
        KeyCount++
    }
    while (KeyCount>1) {
        ChaosWindowGUIDArray.removeat(KeyCount)
        KeyCount--
    }
return

Capslock & 4::
caps_5:
chaosBounce:=1
    MouseGetPos,,,ChaosWindowGUID
for key, val in ChaosWindowGUIDArray { 
    if (ChaosWindowGUID=val) {
        return
    }
}
sleep 50
CounterWinBack2++
CounterWinBack3++
ChaosWindowGUIDArray[CounterWinBack2]:=ChaosWindowGUID
winActivate, ahk_ID %ChaosWindowGUID%
        WinGetActiveStats, TitleNO, NOWidth, NOHeight, NoXW, NoXY
        WinName[CounterWinBack2]:=TitleNO
        WinNameNW[CounterWinBack2]:=NOWidth
        WinNameNH[CounterWinBack2]:=NOHeight
        WinNameNoXW[CounterWinBack2]:=NoXW
        WinNameNoXY[CounterWinBack2]:=NoXY
        MonArray:=monitorFunc()
for key, val in MonArray {
    ChaosArray[CounterWinBack3]:=val
    CounterWinBack3++
}    
CounterWinBack3--    

                        ;6            7        1
                        ;12            13        
    AHKCHAOSID:=ChaosWindowGUIDArray[CounterWinBack2]
    ChaosX[CounterWinBack2]:=((ChaosArray[CounterWinBack3-4] + ChaosArray[CounterWinBack3]/2)-WinNameNW[CounterWinBack2]/2)
    ChaosY[CounterWinBack2]:=((ChaosArray[CounterWinBack3-5] + ChaosArray[CounterWinBack3-1]/2)-WinNameNH[CounterWinBack2]/2)

    WinMove, ahk_ID %AHKCHAOSID% , , % ChaosX[CounterWinBack2], % ChaosY[CounterWinBack2]
    RandyRand:=0
RandyRand:=Rand(1,4)
cRand1:=Rand(3.5,4.5)
if(RandyRand=1) {
chaosDirection[CounterWinBack2]:=-cRand1
chaosDirection2[CounterWinBack2]:=-cRand1
} else if(RandyRand=2) {
chaosDirection[CounterWinBack2]:=-cRand1
chaosDirection2[CounterWinBack2]:=cRand1
} else if(RandyRand=3) {
chaosDirection[CounterWinBack2]:=cRand1
chaosDirection2[CounterWinBack2]:=-cRand1
} else if(RandyRand=4) {
chaosDirection[CounterWinBack2]:=cRand1
chaosDirection2[CounterWinBack2]:=cRand1
}
chaosRandySkip:=1
sleep 100
setTimer, ChaosTimer, 50
setTimer, ChaosTimer, on
return                                                            

; --- Hide Window (Caps+A) has been DISABLED ---
; --- This feature is high-risk. Re-enable by removing comments ---
/*
Capslock & A::
CapsA:
;SetTimer, ActivateWinUM, off
    sleep 50
    donesubcapsa:=1
    CounterWinBack++
    while (donesubcapsa=1)
        sleep 1
WinGet, ChaosWindowGUID , ID
stopToggle:=ChaosWindowGUID
        WinGetActiveStats, TitleNO2, NOWidth2, NOHeight2, NoXW2, NoXY2    


        WinName2[CounterWinBack]:=TitleNO2
        WinNameNW2[CounterWinBack]:=NOWidth2
        WinNameNH2[CounterWinBack]:=NOHeight2
        WinNameNoXW2[CounterWinBack]:=NoXW2
        WinNameNoXY2[CounterWinBack]:=NoXY2
        MonArray2:=monitorFunc()
        BlockInput, on
        mousemove, 0, 0
        WinMove A, , % (MonArray2[2] + MonArray2[6]/2)-NOWidth2/2, % (MonArray2[1] + MonArray2[5]/2)-NOHeight2/2
sleep 1    
coordmode, mouse, window
xRand:=Rand(0,NOWidth2)
yRand:=Rand(0,NOHeight2)
bRand:=Rand(1,4)
if(bRand=1) {
mousemove, 0-50, yRand
} else if(bRand=2) {
mousemove, NOWidth2+50, yRand
} else if(bRand=3) {
mousemove, xRand, NOHeight2+50
} else if(bRand=4) {
mousemove, xRand, 0-50
}
coordmode, mouse, screen
BlockInput, off
return        ;;;;
*/
 
Capslock & Y::
caps_y:
ShowOsdMessage("Reloading...", 1.5)
sleep 1500

for key, value in WinDisable {
    ShowOsdMessage("Reloading... Searching for disabled windows...", 0.2)
    sleep 200
    if (value!="REMOVEME") {
        WinSet, enable, , %value%
        ShowOsdMessage("Reloading... window " value " enabled...", 0.5)
        sleep 500
    }
}
for key, value in OnTopArray {
    ShowOsdMessage("Reloading... Searching for On Top windows...", 0.2)
    sleep 200
    if (value=1){    
    winset, AlwaysOntop, Off, %key%
    ShowOsdMessage("Reloading... ontop off for " key "...", 0.5)
    sleep 500
    }
}
reload
return

Capslock & B::
    ShowOsdMessage("1: clear ALL settings | 2: clear NON-ACCOUNT settings | Other: cancel.", 20)
    Input, Outputvar, L1
    if(Outputvar="1") {
        run cmd /c rd /s /q %CS%
        ShowOsdMessage("ALL settings cleared. Reload in 2 sec...", 2)
        sleep 2000
        goto caps_y
    } else if (Outputvar="2") {
        ; Delete all sections except [Accounts] and [AccountWindowPos]
        IniRead, Sections, %ConfigPath%
        Loop, parse, Sections, `n
        {
            CurrentSection := A_LoopField
            if (CurrentSection != "Accounts" AND CurrentSection != "AccountWindowPos")
            {
                IniDelete, %ConfigPath%, %CurrentSection%
            }
        }
        ; Delete clipboard history (now handled by clipboard.txt deletion)
        ; IniDelete, %ConfigPath%, Clipboard 
        ifExist, %CS%clipboard.txt
            fileDelete, %CS%clipboard.txt
        
        ShowOsdMessage("NON-ACCOUNT settings cleared. Reload in 2 sec...", 2)
        sleep 2000
        goto caps_y
    } else {
        ShowOsdMessage("Canceled.", 2)
    }
return

Capslock & V::
if (Debug=1) {
Debug:=0
GuiConF(5,2,-1,-1)
    ShowOsdMessage("Debug Disabled.", 2)
} else {
Debug:=1
    ShowOsdMessage("Debug Enabled.", 2)
}
return

Capslock & H::
MouseGetPos,,, WinUMID2
WinActivate, ahk_id %WinUMID2%
WinGet, ProcessID, PID, A
    Run cmd.exe /c taskkill /f /PID %ProcessID%
return

;--- RuneLite Specific Global Hotkeys ---
#If isRuneliteRunning() and (KeySet=1 or KeySet=2 or !KeySet) and InitFinish=1

Capslock & N::
    ShowOsdMessage("Preparing to shutdown down all runelites...", 7)
soundplay, %A_ScriptDir%\CustomSound\godno.wav, wait
sleep 7
    ShowOsdMessage("Shutting down all runelites!", 2)
Run cmd.exe /c taskkill /f /im "runelite.exe"
return

Capslock & enter::
Send, {enter} 

$Capslock::
do_capslock:
if (ActiveToggle=1)
	settimer, ActivateWinUM, off
WinGetActiveTitle, capsTitle
capsTitle:= % SubStr(capsTitle, 12)
valuesinaccount:=0
CurrentAccKey:=-1
for precapskey in Account {
    valuesinaccount++
    if (Account[precapskey]=capsTitle)
        CurrentAccKey:=valuesinaccount
}
ifWinNotExist, % LastFocused 
{
checklastfocused:=0
GroupActivate, RuneliteD, r
;return
}
if (CurrentAccKey=-1) {
LastFocusedName:=Substr(LastFocused,12)
for precapskey2 in Account {
    if (Account[precapskey]=LastFocusedName)
        CurrentAccKey:=valuesinaccount
}
}
if(CurrentAccKey=valuesinaccount){
NextKeyCaps:=0
} else {
NextKeyCaps:=CurrentAccKey
}
while (True) {
    NextKeyCaps++
    NextAccount = % Account[NextKeyCaps]
    if (NextKeyCaps = CurrentAccKey) {
        GroupActivate, RuneliteD, r
        break
    }
    ifWinExist, % "RuneLite - "NextAccount
    {
        WinActivate, % "RuneLite - "NextAccount
        break
    }
    if (NextKeyCaps>=valuesinaccount) {
         NextKeyCaps:=0
    }
}
donesubcapsa:=0
GoSub, UpdateOSD
WinGetActiveTitle, capsTitle
capsWinUMSwitch:=1
if (ActiveToggle=1)
	settimer, ActivateWinUM, on
return

#If ; End Global Hotkeys
;#######################################################################################################################
;#######################################################################################################################
;
;   SECTION 4: CONTEXT-SENSITIVE HOTKEYS
;
;#######################################################################################################################
;#######################################################################################################################

;=================================================
;   OSD HOTKEYS (KeySet=1)
;=================================================
#If KeySet=1 and InitFinish=1

Capslock & F::
if (!MarkersNotesMagnifiers or MarkersNotesMagnifiers="Notes") {
MarkersNotesMagnifiers=Markers
ShowOsdMessage("Current Caps + LB/RB/MB/C/X selections set to MARKERS.", 2)
} else if (MarkersNotesMagnifiers="Markers") {
MarkersNotesMagnifiers=Magnifiers
ShowOsdMessage("Current Caps + LB/RB/MB/C/X selections set to MAGNIFIERS.", 2)
} else if (MarkersNotesMagnifiers="Magnifiers") {
MarkersNotesMagnifiers=Counter
ShowOsdMessage("Current Caps + LB/RB/MB/C/X selections set to COUNTER.", 2)
} else {
MarkersNotesMagnifiers=Notes
ShowOsdMessage("Current Caps + LB/RB/MB/C/X selections set to NOTES.", 2)
}
return

;--- Mode: Counter ---
#if MarkersNotesMagnifiers="Counter" and KeySet=1 and InitFinish=1
Capslock & LButton::
GlobalMouseCounter++
ShowOsdMessage(GlobalMouseCounter, 2)
return
Capslock & RButton::
GlobalMouseCounter:=0
ShowOsdMessage("Counter Reset", 2)
;GuiConf("COUNTER_",2,-1, -1)
return
#if ; End Counter Mode

;--- Mode: Notes ---
#if MarkersNotesMagnifiers="Notes" and KeySet=1 and InitFinish=1
Capslock & RButton::
if (SelNote<300 or SelNote>=NoteCounter)
    SelNote:=NumAccs+300
if(SubStr(3String, 1, 12)="Current note")
    SelNote++
if (SelNote=NumAccs+300)
    SelNote:=NumAccs+300+1
NoteCounterT:=NoteCounter-NoteSafety
SelMNote:=SelNote-(NumAccs)-300
ShowOsdMessage("Current note - " SelMNote "/" NoteCounterT ". 1: move/show. 2: hide.", 5)
Input, Outputvar, L1 T3
if(Outputvar="1") {
MouseGetPos, NoteX, NoteY
NoteSel=Note_%SelNote%
GuiConF("Note_" SelNote,1,NoteX,NoteY) 
} else if (Outputvar="2") {
SkipCounter++
GuiConF("Note_" SelNote,2,-1,-1)
NoteSkipArray[SkipCounter]:=SelNote
GuiActiveArray[SelNote]:=5
} else {
    ShowOsdMessage("Canceled.", 2)
}
return

Capslock & LButton::
if (!TempGUI or TempGUI!="TempGUI") {
NoteString:=
!NoteString
MouseGetPos, NoteX, NoteY
NoteSafety:=NumAccs+300
if (NoteCounter<NoteSafety or !NoteCounter)
    NoteCounter=%NoteSafety%
NoteCounter++
TempGUI:="TempGUI"
OutlineBuilder(TempGUI)
BuildGUI(TempGUI)
GuiConF(TempGUI, 3, "______", -1)    
GuiRandColor(TempGUI)
GuiConF(TempGUI, 1,NoteX-40,NoteY-40)
InputBox, NoteString, Note, Enter a note`, hide or move it with Capslock + RButton., , 275, 175, NoteX+50, NoteY+50
if (!NoteString or NoteString="") {
    ShowOsdMessage("Note Canceled.", 2)
}

if !(3String="Note Canceled.") {
    NoteCounter2=Note_%NoteCounter%
OutlineBuilder(NoteCounter2)
BuildGUI(NoteCounter2)
GuiConF(NoteCounter2,3,NoteString,-1)
GuiRandColor(NoteCounter2)
GuiConF(NoteCounter2,1,NoteX,NoteY) 
}
sleep 500
GuiConF(TempGUI, 2, -1, -1)
TempGUI:=
} else {
    ShowOsdMessage("Please finish what you are doing.", 2)
}
return

Capslock & c::
Counter:=0
TempArray:=Array()
guiactivekey:=
guiactivevalue:=
for guiactivekey, guiactivevalue in GuiActiveArray {
if (guiactivevalue=3 or guiactivevalue=4) {
    GuiConF(guiactivekey, 2, -1, -1)
    GuiActiveArray[guiactivekey]:=0
    if (guiactivevalue=3) {
	Counter++
	}
    }
}
for guiactivekey, guiactivevalue in GuiActiveArray {
    if (guiactivevalue!=3 and guiactivevalue!=4 and guiactivevalue!=0) {
        TempArray[guiactivekey]:=guiactivevalue
    }
}
GuiActiveArray:=TempArray
TempArray:=
Counter:=floor(Counter)
    ShowOsdMessage(Counter " Notes Destroyed.", 2)
    Counter:=
    NoteCounter:=
return
#if ; End Notes Mode

;--- Mode: Markers ---
#if MarkersNotesMagnifiers="Markers" and KeySet=1 and InitFinish=1
Capslock & LButton::
offset:=0
offset2:=0
goto markerPlaceOffsetSkip
markerPlace:
if ((offset1 = "" or offset1 = 0 or offset1 = -20) and (offset2 = "" or offset2 = -20 or offset2=0)) {
	offset1:=20
	offset2:=-20
} else if (offset2 = -20) {
	offset1:=-20
	offset2:=20
}
markerPlaceOffsetSkip:
MouseGetPos, MarkX, MarkY
MarkerSafety:=NumAccs+300
if (MarkerCounter<MarkerSafety or !MarkerCounter)
    MarkerCounter=%MarkerSafety%
MarkerCounter++
MarkerCounter2=_%MarkerCounter%
MarkerCounter4=%asciichar%%MarkerCounter%
MarkerCounter3:=MarkerCounter-MarkerSafety
OutlineBuilder(MarkerCounter4)
BuildGUI(MarkerCounter2)
OutlineBuilder(MarkerCounter2)
GuiConF(MarkerCounter2, 3, asciichar, -1)    
GuiConF(MarkerCounter4, 1,MarkX-80-offset2,MarkY-86-offset1)
GuiRandColor(MarkerCounter2)
GuiConF(MarkerCounter2,1,MarkX-80-offset2,MarkY-85-offset1)
return

Capslock & c::
markerClear:
Counter:=0
TempArray:=Array()
for guiactivekey, guiactivevalue in GuiActiveArray {
if (guiactivevalue=2) {
    GuiConF(guiactivekey, 2, -1, -1)
    GuiActiveArray[guiactivekey]:=0
    Counter++
    }
}
for guiactivekey, guiactivevalue in GuiActiveArray {
if (guiactivevalue!=2 and guiactivevalue!=0 and guiactivevalue!=4) {
        TempArray[guiactivekey]:=guiactivevalue
    } 
}
GuiActiveArray:=TempArray
TempArray:=
Counter:=floor(Counter/2)
    ShowOsdMessage(Counter " Markers Destroyed.", 2)
    Counter:=
    MarkerCounter:=
    MarkerCounter3:=
    MarkerCounter4:=
    MarkerSafety:=
    DotCounter:=0
return

Capslock & RButton::
DotCounter:=0
    ShowOsdMessage("Counter Set to 1", 2)
return
#if ; End Markers Mode

;--- Mode: Magnifiers ---
#if MarkersNotesMagnifiers="Magnifiers" and KeySet=1 and InitFinish=1
Capslock & LButton::
if(!counterPMM or counterPMM<0 or counterPMM>=2)
counterPMM=0
    counterPMM++
if(!counterMM or counterMM<=0)
    counterMM:=0
MouseGetPos x, y
if (counterPMM=1) {
    Rx1 := x+23
    Ry1 := y-15
    OutlineBuilder("X1")
    GuiConF("X1", 1,x-84,y-86)
        ShowOsdMessage("Top Left corner set.", 2)
} else if (counterPMM=2) {
    Rx2 := x+18
    Ry2 := y+5
        ShowOsdMessage("Bottom Right corner set.", 2)
    GuiConF("X1Outline1", 2, -1, -1)
    counterMM++
    zoom := 3              
    ResX[counterMM] := Rx2-Rx1
    Rx := ResX[counterMM]
    ResY[counterMM] := Ry2-Ry1
    Ry := ResY[counterMM]
    Gui Magnifier%counterMM%: Default
    Gui Magnifier%counterMM%: new, +AlwaysOnTop -0xC00000
    Gui Show, % "w" ((2*Rx)) " h" ((2*Ry)) " x" x " y" y "", Magnifier%counterMM%
    WinGet MagnifierID, id,  Magnifier%counterMM%
    WinGet PrintSourceID, ID
    hdd_frame[counterMM] := DllCall("GetDC", UInt, PrintSourceID)
    hdc_frame[counterMM] := DllCall("GetDC", UInt, MagnifierID)
    ;WinSet, Style, ^0xC00000
    Zx[counterMM] := ResX[counterMM]/zoom           ; frame x/y size
    Zy[counterMM] := ResY[counterMM]/zoom
    x2[counterMM] := Rx2-Zx[counterMM]-(rx/zoom)
    y2[counterMM] := Ry2-Zy[counterMM]
    SetTimer Repaint, 50
    setTimer, Repaint, on
}
return

Capslock & c::
counterM:=0
counterM2:=0
counterMM:=0
for key, value in hdd_frame{
DllCall("gdi32.dll\DeleteDC"    , UInt,value )
hdd_frame[key]:="removeme"
}
for key, value in hdc_frame{
DllCall("gdi32.dll\DeleteDC"    , UInt,value )
winclose Magnifier%key%
keyCount++
hdc_frame[key]:="removeme"
}
    ShowOsdMessage("Removed " keyCount " Magnifiers.", 2)
while (keyCount>0) {
if (hdd_frame[keyCount]="removeme") {
    hdd_frame.RemoveAt(keyCount)
}
if (hdc_frame[keyCount]="removeme") {
    hdc_frame.RemoveAt(keyCount)
}
keyCount--
}
    MouseFollowMagID:=0
    MouseFollowMag:=0
return

Capslock & RButton::
if(!counterM or counterM<0 or counterM>=counterMM)
    counterM:=0
destroyed_tryagain:
if(SubStr(3String, 1, 9)="Magnifier")
    counterM++
if (counterM=0)
    counterM:=1
    ShowOsdMessage("Magnifier" counterM ": 1-location, 2-window, 3-mouse/tick, 4-destroy", 10)
    if (hdd_frame[counterM]="destroyed")
        goto destroyed_tryagain
Input, Outputvar, L1 T10
if(Outputvar="1") {
MouseGetPos x2x, y2y
zoom := 3
Zx[counterM] := ResX[counterM]/zoom  ; zoom           ; frame x/y size
Zy[counterM] := ResY[counterM]/zoom
x2[counterM] := x2x-Zx[counterM]+(ResX[counterM]/zoom)/2
y2[counterM] := y2y-Zy[counterM]+(ResY[counterM]/zoom)
    ShowOsdMessage("Magnified Location of Magnifier" counterM " set", 3)
    return
} else if (Outputvar="2") {
MouseGetPos x2x, y2y
WinActivate, Magnifier%counterM%
WinMove A, , % x2x, % y2y
winset, AlwaysOntop, On, A
    ShowOsdMessage("Magnifier" counterM " window position set.", 3)
    return
} else if (Outputvar="4") {
DllCall("gdi32.dll\DeleteDC"    , UInt,hdd_frame[counterM] )
DllCall("gdi32.dll\DeleteDC"    , UInt,hdc_frame[counterM] )
    ShowOsdMessage("Magnifier" counterM " destroyed.", 3)
    winclose Magnifier%counterM%
    hdd_frame[counterM]:="destroyed"
    if (MouseFollowMagID=counterM) { 
        MouseFollowMagID:=0
        MouseFollowMag:=0
    }
        return
} else if (Outputvar="3") {
        MouseFollowMag++
        if (MouseFollowMag=1) {
            ShowOsdMessage("Magnifier" counterM " is following mouse.", 10)
        } else if (MouseFollowMag=2 and tickHUD=1) {
            ShowOsdMessage("Magnifier" counterM " is following tick counter.", 10)
        } else {
            ShowOsdMessage("Disabled following of cursor/tickcounter", 10)
            MouseFollowMag:=0
        }
        MouseFollowMagID:=CounterM
        return
} else {
    ShowOsdMessage("Canceled.", 2)
}
return
#if ; End Magnifiers Mode

;--- General OSD Hotkeys (KeySet=1) ---
#If KeySet=1 and InitFinish=1

Capslock & x::
TickTockTickTock:=0
tickLimit=NaN
initTick:=-1
if (tickHUD=1) {
        ShowOsdMessage("Tick Counter Active. 1: disable, 2: change count, 3: change style", 5)
    Input, Outputvar, L1 T5
    if(Outputvar="1") {
    tickHUD:=0
        ShowOsdMessage("Tick Counter turned off", 2)
    } else if(Outputvar="2") {
    MouseGetPos, MgetX, MgetY
                    MgetX4:=MgetX+10
                    MgetY4:=MgetY+10                
    InputBox, tickLimit, Tick Count Limit, Enter the number of ticks to count up to`, this repeats until canceled. If you enter 0 or 1`, it will just count forever., , 275, 175, MgetX4, MgetY4
    IniWrite, %tickLimit%, %ConfigPath%, TickCounter, Limit
    } else if(Outputvar="3") {
        if (tickDisplaySetting=1 or tickDisplaySetting>3 or tickDisplaySetting<1) {
            tickDisplaySetting:=2
			tickMonArray:=monitorFunc()
			CurDisplayW:=tickMonArray[6]
			CurDisplayH:=tickMonArray[5]
			CurDisplayY:=tickMonArray[1]
			CurDisplayX:=tickMonArray[2]
        } else if (tickDisplaySetting=2) {
            tickDisplaySetting:=3
        } else if (tickDisplaySetting=3) {
            tickDisplaySetting:=1
			}
        IniWrite, %tickDisplaySetting%, %ConfigPath%, TickCounter, DisplaySetting
    }
} else {
	tickHUD:=1
	boredCounter:=1
	setTimer, tickHUD, 600
	setTimer, tickHUD, on
    ShowOsdMessage("Creating tick counter.", 2)
    temp:=
    boredCounter:=Rand(1,2)
    if (boredCounter=2)
        boredCounter=-1
    boredCounter2:=Rand(1,2)
    if (boredCounter2=2)
        boredCounter2=-1
    boredDirection:=Rand(1,2)
    if (boredDirection=2)
        boredDirection=-1
    boredDirection2:=Rand(1,2)
    if (boredDirection2=2)
        boredDirection2=-1
    angle := Rand(0,360)

    if (tickDisplaySetting=5 or tickDisplaySetting=2) {
		tickMonArray:=monitorFunc()
		CurDisplayW:=tickMonArray[6]
		CurDisplayH:=tickMonArray[5]
		CurDisplayY:=tickMonArray[1]
		CurDisplayX:=tickMonArray[2]
    }
    
    IniRead, tickLimit, %ConfigPath%, TickCounter, Limit, -1
    if (tickLimit = -1 or tickLimit = "ERROR") {
        tickTryAgain:
        MouseGetPos, MgetX, MgetY
                        MgetX4:=MgetX+10
                        MgetY4:=MgetY+10                
        InputBox, tickLimit, Tick Count Limit, RESET THIS NUMBER WITH CAPSLOCK + N. -- Enter the number of ticks to count up to`, this repeats until canceled. If you enter 0 or 1`, it will just count forever.. LEFT ALT + B changes the display mode, , 380, 175, MgetX4-190, MgetY4-100
        if (tickLimit and (tickLimit<=0 or tickLimit>=0)){
            IniWrite, %tickLimit%, %ConfigPath%, TickCounter, Limit
        } else {
            ShowOsdMessage("Please enter a number.", 5)
            goto tickTryAgain
        }    
    }
}
IniRead, tickLimit, %ConfigPath%, TickCounter, Limit
return

Capslock & Z::
    ShowOsdMessage("Z: stick/unstick | 1: hide/show messages | 2: hide/show nameplates", 5)
    Input, Outputvar, L1 T5
    if(Outputvar="2") {
        if (GUI_Names=0) {
        WinGetActiveTitle, aTitleZ
                ShowOsdMessage("OSD Name plates are now being shown", 2)
            GUI_Names=1
            IniWrite, %GUI_Names%, %ConfigPath%, OSD, ShowNameplates
            GuiNumber:=1
            O_Title:=NaN
            GoSub, UpdateOSD
            WinActivate, %aTitleZ%
            return
        } else {
                ShowOsdMessage("OSD Name plates are now being hidden", 2)
                GUI_Names=0
            IniWrite, %GUI_Names%, %ConfigPath%, OSD, ShowNameplates
            GuiConF(1,2,-1,-1)
        }    
    } else if (Outputvar="1") {
        if (MouseMessages=0) {
            MouseMessages:=1
                ShowOsdMessage("These messages are now being shown", 2)
            IniWrite, %MouseMessages%, %ConfigPath%, OSD, ShowMessages
        } else {
        ShowOsdMessage("These messages are now being hidden", 1)
                sleep 2000
            MouseMessages=0
            IniWrite, %MouseMessages%, %ConfigPath%, OSD, ShowMessages
        }    
    } else if (Outputvar="Z") {
if(!stopThreeGo or stopThreeGo=0) {
    ShowOsdMessage("Cursor objects stuck to location.", 2)
	stopThreeGo:=1
} else {
    ShowOsdMessage("Cursor objects stuck to cursor.", 2)
	stopThreeGo:=0
}
}    else {
        ShowOsdMessage("Canceled.", 2)
    }
return

Capslock & w::
    Keywait, w
    if (WaitJustOneFuckingSecond>=0) {
        ShowOsdMessage("Please Wait", 1)
        return
    } else {
        WaitJustOneFuckingSecond=2
        SetTimer, 1fuckingsecondtimer, on
        if (TimerIsPaused=0) {
            TimerIsPaused:=1
            TimerIsRunning:=0
            IniWrite, %TimerIsPaused%, %ConfigPath%, Timers, Paused
            IniWrite, %GlobalTimerMinR%, %ConfigPath%, Timers, PausedMinutes
            IniWrite, %GlobalSecondDisplay%, %ConfigPath%, Timers, PausedSeconds
            ShowOsdMessage("Timer Paused and Saved", 1)
            return
        } else if (TimerIsPaused=1) {
            IniRead, GlobalTimerMinutes, %ConfigPath%, Timers, GlobalMinutes
            IniRead, GlobalTimerMinR, %ConfigPath%, Timers, PausedMinutes
            IniRead, GlobalSecondDisplay, %ConfigPath%, Timers, PausedSeconds

            if (GlobalTimerMinutes = "ERROR" or GlobalTimerMinR = "ERROR" or GlobalSecondDisplay = "ERROR")
            {
                Timer_Load_Error() ; Changed from goto
            }
            
            IniDelete, %ConfigPath%, Timers, Paused
            IniDelete, %ConfigPath%, Timers, PausedMinutes
            IniDelete, %ConfigPath%, Timers, PausedSeconds
            TimerIsRunning:=1
            TimerIsPaused:=0
            SetTimer, UpdateOSD2, on

            ShowOsdMessage("Timer Resumed", 1)
            return
    }
}
return

caps_f:
Outputvar:=2
goto skipinput_timers
capslock & e::
    ShowOsdMessage("1: set global timer | 2: set account timer", 5)
    Input, Outputvar, L1 T5
    skipinput_timers:
    if(Outputvar="1") {
if (WaitJustOneFuckingSecond>=0) {
    ShowOsdMessage("Please Wait", 1)
    return
} else {
    WaitJustOneFuckingSecond=1
    SetTimer, 1fuckingsecondtimer, on    
    if(TimerIsPaused=0 and TimerIsRunning=0) {
        if (SetGlobalTimerMinutes()) {
            StartGlobalTimer() 
        }
    } else {
        ShowOsdMessage("Please clear current timer first.", 2)
    }
}
} else if (Outputvar="2") {
WinGetActiveTitle, aTitleT
MouseGetPos, ATMouseX, ATMouseY
                InputBoxX:=ATMouseX-105
                InputBoxY:=ATMouseY-20
                InputBox, AccTimerTime, Timer Time, Enter the number of minutes, , 210, 130, InputBoxX, InputBoxY
                IniWrite, %AccTimerTime%, %ConfigPath%, Timers, AccTimerMinutes

                If (!AccTimerTime or AccTimerTime<=0)
                    {
                        CapsTAccTimersCounter:=0
                        ShowOsdMessage("No Time was entered", 1)
                        return
                    } else {
                        if (CapsTAccTimersCounter!=0) {
                            CapsTAccTimersCounter:=0
                            WinActivate, %aTitleT%
                            goto caps_ast
                        }
                        CapsTAccTimersCounter:=0
                    }        
} else {
    ShowOsdMessage("Canceled.", 2)
}
return

Capslock & t::
caps_ast:
IniRead, AccTimerTime, %ConfigPath%, Timers, AccTimerMinutes
if(CapsTAccTimersCounter!=0)
    return
while (CapsTAccTimersCounter<=NumAccs) {
WinGetActiveTitle, aTitleT
    CapsTAccTimersCounter++
    AccTimerAcc = % Account[CapsTAccTimersCounter]
;        msgbox, % AccTimerAcc
;		msgbox, % aTitleT
        If (aTitleT="RuneLite - "AccTimerAcc) {
			
            if (!AccTimerTSec[CapsTAccTimersCounter]) {
                If (!AccTimerTime)
                    {
                        goto caps_f
                    }
                GuiNumber:=CapsTAccTimersCounter+NumAccs
                OutlineCounter:=0
                OutlineID=%GuiNumber%Outline
                OOutlineID:=OutlineID
                OutlineBuilder(GuiNumber)
                BuildGUI(GuiNumber)
                GuiNumber:=CapsTAccTimersCounter+NumAccs
                ShowOsdMessage("Starting Timer for " AccTimerAcc, 1)
                WinGet, WinId, ID, A
                ASTWindow[CapsTAccTimersCounter]:=WinId
                AccTimerTSec[CapsTAccTimersCounter]:=floor((AccTimerTime*60))
                CapsTAccTimersCounter:=0
                SetTimer, AccTimers, on
                break
                return
            } else {
                GuiNumber:=CapsTAccTimersCounter+NumAccs
                OutlineID=%GuiNumber%Outline
                GuiConF(GuiNumber,2,-1,-1)
                AccTimerTSec[CapsTAccTimersCounter]:=""
                ShowOsdMessage("Timer Cleared for " AccTimerAcc, 1)
                CapsTAccTimersCounter:=0
                break
                return
            }
        } else if (CapsTAccTimersCounter=>NumAccs) {
            ShowOsdMessage("Please focus a runelite window with a known account.", 1)
            CapsTAccTimersCounter:=0
            break
            return
        }        
    }
return

Capslock & q::
Keywait, q
timer_t:
if (WaitJustOneFuckingSecond>0 and TimerIsRunning=0) {
    ShowOsdMessage("Please Wait", 1)
    return
} else {
    WaitJustOneFuckingSecond=2
    SetTimer, 1fuckingsecondtimer, on
    IniRead, GlobalTimerMinutes, %ConfigPath%, Timers, GlobalMinutes
    
    if (GlobalTimerMinutes = "ERROR" OR !GlobalTimerMinutes) {
        if (SetGlobalTimerMinutes()) { 
            StartGlobalTimer()
        }
        return 
    }
    
if (TimerIsRunning=0 and TimerIsPaused=0) {
    if (!GlobalTimerMinutes or GlobalTimerMinutes <= 0) {
        if (SetGlobalTimerMinutes()) {
            StartGlobalTimer() 
        }
        return
    }
    StartGlobalTimer() 
    return 
    } else if(TimerTimeStr="TIME"){
            ClearGlobalTimer()
    } else if(TimerIsPaused=1 and TimerResetWarning=0) {
        ShowOsdMessage("Timer Paused - Caps+W to Resume - Caps+Q again to Reset", 6)
        TimerResetWarning++
        return     
    } else if ((TimerIsRunning=1 or TimerIsPaused=1) and TimerResetWarning=0) {
        ShowOsdMessage("Timer currently running - Press Caps+Q again to reset.", 1)
        TimerResetWarning++
        return
    } else if (TimerResetWarning=1 and (TimerIsRunning=1 or TimerIsPaused>=1)) {
        ClearGlobalTimer()
    }     
}
return

Capslock & 3::
    ShowOsdMessage("3 to count up, 2 to clear.", 1)
        Input, Outputvar, L1 V T1
        if(Outputvar="3") {
thecounterupdo:
CounterVar=0
last_type:=%count_type%
WinGetActiveTitle, Title
if (!CounterFuncArray[count_type]) {
    CounterFuncArray[count_type]:=0
}

    CounterFuncArray[count_type]++
    counterkey=% CounterFuncArray[count_type]

} else if(Outputvar="2") {
        ShowOsdMessage("Counter Cleared", 1)
        thecounterresetdo:
        CounterVar=0
        holdvar:=1
        if (CounterFuncArray[count_type]) {
            CounterFuncArray[count_type]:=0
        }
        counterkey=% CounterFuncArray[count_type]
    }
return

;--- OSD Plate Movement ---
Capslock & Right::
OSD_MOVE:=OSD_MOVE+25
goto osdmovekeysavewait
Capslock & Left::
OSD_MOVE:=OSD_MOVE-25
goto osdmovekeysavewait
Capslock & Up::
OSD_MOVE2:=OSD_MOVE2-7
goto osdmovekeysavewait
Capslock & Down::
OSD_MOVE2:=OSD_MOVE2+7
goto osdmovekeysavewait
;----------
osdmovekeysavewait:
if (SaveWaitCounter<=0) {
    SaveWaitCounter=2
    SetTimer, SaveWait, on
}
return

#If ; End KeySet=1

;=================================================
;   WINDOW MGMT HOTKEYS (KeySet=2)
;=================================================
#If KeySet=2 and InitFinish=1

capslock & g::
ContName:=""
ControllerNumber:=0
controller_check_var:=1
controllerCheck() ; Changed from gosub
if (controller_check_var==2) {
	controller_check_var:=0
	return
}
controller_check_var:=0
	WinGetClass,Controller_Window_Focus,A
	if (Controller_Window_Focus!="Shell_TrayWnd") {
		ShowOsdMessage("Controller will activate ahk_class " Controller_Window_Focus, 2)
	} else {
		ShowOsdMessage("Controller activation window focusing disabled.", 2)
	}
	IniWrite, %Controller_Window_Focus%, %ConfigPath%, Controller, FocusClass
return

Capslock & u::  ;;;;;;    <--- This is to toggle on/off the automatic window focus of runelite under the cursor
Keywait, u
    IniWrite, %ActiveToggle%, %ConfigPath%, WindowMgmt, AutoFocus
		
if (ActiveToggle=1) {
ActiveToggle:=0
SetTimer, ActivateWinUM, off
ShowOsdMessage("No longer activating Runelites under cursor", 2)
} else {
ShowOsdMessage("Activating Runelites under cursor", 2)
ActiveToggle:=1
SetTimer, ActivateWinUM, on
}
return

Capslock & 3::
    MouseGetPos,,,guidUnderCursor
    WinGetTitle, TitleUnderCursor, ahk_id %guidUnderCursor%
for WinDisableKey, WinDisableVal in WinDisable {
    if (WinDisableVal=guidUnderCursor) {
        Winset, enable, , ahk_id %guidUnderCursor%
        WinActivate, %guidUnderCursor%
        ShowOsdMessage(TitleUnderCursor " ENABLED interaction.", 4)
        WinDisable[WinDisableKey]:="REMOVEME"
        return
    }    
}
if (!WinDisableCounter or WinDisableCounter<0)
    WinDisableCounter:=0
WinDisableCounter++
WinDisable[WinDisableCounter]:=guidUnderCursor
Winset, disable, , ahk_id %guidUnderCursor%
WinActivate, ahk_class Shell_TrayWnd
WinSet, AlwaysOnTop, on, ahk_class Shell_TrayWnd
ShowOsdMessage(TitleUnderCursor " DISABLED interaction.", 4)
return

Capslock & q:: ;;window ontop or not
keywait, q
WinGetTitle, A_Title, A
    if (OnTopArray[A_Title]=1) {
    WinSet, AlwaysOnTop, Off, A

    ShowOsdMessage("Always Ontop - OFF - for " A_Title, 1)
        OnTopArray[A_Title]:=0
    } else { 
        WinSet, AlwaysOnTop, on, A
    OnTopArray[A_Title]:=1
    ShowOsdMessage("Always Ontop - ON - for " A_Title, 1)
for GuiKeyCheck, GuiValueCheck in GuiActiveArray {
    if instr(GuiKeyCheck,"Outline") { 
        Gui, %GuiKeyCheck%: +AlwaysOnTop
    }
}
for GuiKeyCheck, GuiValueCheck in GuiActiveArray {    
    if !instr(GuiKeyCheck,"Outline") { 
        Gui, %GuiKeyCheck%: +AlwaysOnTop
    }
}
}
return

Capslock & R:: 
GroupAdd, RuneliteD, RuneLite - 
WinGet, RuneliteDWindowCount, Count, ahk_group RuneliteD
;msgbox, % RuneliteDWindowCount
WindowPosSetCounter:=0
moveWins:=0
MsgboxMove_String=Move or Save
ChangeBtnNames:=1
Btn1_Name=Move ; YES
Btn2_Name=Save ; ELSE
SetTimer, MsgboxMove, on
MsgBox, 4, %MsgboxMove_String%, Would you like to Move to your saved Runelite positions, or save the current Runelite positions?
ifMsgBox, YES
{
moveWins:=1
}
setTimer, ActivateWinUM, off
while (WindowPosSetCounter<=RuneliteDWindowCount) {
	GroupActivate, RuneliteD, r
	WinGetActiveStats, yTitle, ywWidth, ywHeight, yWX, yWY
	WindowPosSetCounter++
	If (moveWins=1) {
        IniRead, settingsString2, %ConfigPath%, AccountWindowPos, %yTitle%
		if (settingsString2 != "ERROR" AND settingsString2 != "")
		{
			settingsObject2 := StrSplit(settingsString2, "|")
			WinSet, Style, -0xC00000, A
			send, {f11}
			sleep, 100
			send, {f11}
			sleep, 100
			WinMove A, , % settingsObject2[1], % settingsObject2[2], % settingsObject2[3], % settingsObject2[4]
			
		}
	} else { 
			SaveString=%yWX%|%yWY%|%ywWidth%|%ywHeight%
            IniWrite, %SaveString%, %ConfigPath%, AccountWindowPos, %yTitle%
	}
}
IniRead, ActiveToggle, %ConfigPath%, WindowMgmt, AutoFocus, 0
if (ActiveToggle = 1) {
    SetTimer, ActivateWinUM, on
} else {
    SetTimer, ActivateWinUM, off
}
return

Capslock & W::
WinGetActiveTitle, aTitle5
WinGet, curtrans, Transparent, A
if (!curtrans)
    curtrans = 255
newtrans := curtrans - 20
if (newtrans>0) {
    WinSet, Transparent, %newtrans%, A
    ShowOsdMessage("Window " aTitle5 " Opacity Decreased " newtrans ".", 1)
} else {
    ShowOsdMessage("Window " aTitle5 " Opacity Reset.", 1)
    WinSet, Transparent, 255, A
    WinSet, Transparent, OFF, A
}
return

Capslock & E::
WinGetActiveTitle, aTitle5
WinGet, curtrans, Transparent, A
if (!curtrans)
    curtrans = 255
newtrans := curtrans + 16
if (newtrans>255)
	newtrans:=255
if (newtrans>0) {
    WinSet, Transparent, %newtrans%, A
    ShowOsdMessage("Window " aTitle5 " Opacity Increased " newtrans ".", 1)
} else {
    ShowOsdMessage("Window " aTitle5 " Opacity Reset.", 1)
    WinSet, Transparent, 255, A
    WinSet, Transparent, OFF, A
}
return

Capslock & C::
MouseGetPos,,, WinUMID2
WinSet, Style, ^0xC00000, ahk_id %WinUMID2%
return

#If ; End KeySet=2
;#######################################################################################################################
;#######################################################################################################################
;
;   SECTION 5: TIMERS
;
;#######################################################################################################################
;#######################################################################################################################

1fuckingsecondtimer: ; Renamed back
WaitJustOneFuckingSecond--
if (WaitJustOneFuckingSecond<=2) {
}
if (WaitJustOneFuckingSecond<=-1) {
    SetTimer, 1fuckingsecondtimer, off
}
return

AccTimers:
AccTimersTimerCounter++
ATimersCC:=0
for keyATimersCC, valueATimersCC in AccTimerTSec {
    if (valueATimersCC>=0) {
        ATimersCC++
    }
}
if (ATimersCC<=0) {
    SetTimer, AccTimers, off
    return
}
fkbud:
if (WaitJustOneFuckingSecond<=-1) {
    WinGetActiveTitle, aTitle2
    for KATimerFP, WinId in ASTWindow {
        if (WinExist("ahk_id " . WinId)) {
            GuiFkBud:=KATimerFP+NumAccs

            if (aTitle2="RuneLite - "Account[KATimerFP] and (ATimersIsOntop[KATimerFP]=0 or !ATimersIsOntop[KATimerFP])) {
                GuiConF(GuiFkBud,4,1,-1)
                ATimersIsOntop[KATimerFP]:=1
            } else if (ATimersIsOntop[KATimerFP]=1 and aTitle2!="RuneLite - "Account[KATimerFP]) { 
                GuiConF(GuiFkBud,4,0,-1)
                ATimersIsOntop[KATimerFP]:=0
            }

            if (AccTimerTSec[KATimerFP] >= 0) {
                WinGetPos, TimerMgetX, TimerMGetY, WWW, HHH, ahk_id %WinId%
                TimerMgetX:=TimerMgetX+OSD_MOVE+40
                TimerMGetY:=TimerMGetY+OSD_MOVE2+120
                GuiRandColor(GuiFkBud)
                GuiControl, +c%AccountGUIColor%, MyText
                if (TimerMgetX and TimerMGetY)
                    GuiConF(GuiFkBud,1,TimerMgetX,TimerMGetY)

                ; Update timer display
                LocalAccMin := Floor(AccTimerTSec[KATimerFP] / 60)
                LocalAccSec := Mod(AccTimerTSec[KATimerFP], 60)
                AccTimerTimeStrVAR := LocalAccMin ":" (LocalAccSec < 10 ? "0" : "") LocalAccSec
                GuiConF(GuiFkBud, 3, AccTimerTimeStrVAR, -1)
            }
        }
    }        
}

if (AccTimersTimerCounter>=1) {
    AccTimersTimerCounter:=0
    for keyAccTimers, value in AccTimerTSec {
        if (value != "") {
            if (value = 0) {
                AltAlarmSound:=1
                PlaySound:=1
                SetTimer, AlarmSound, 750
                SetTimer, AlarmSound, on
                GuiConF(keyAccTimers+NumAccs, 2, -1, -1) ; Hide the timer
                AccTimerTSec[keyAccTimers]:="" ; Clear the timer
            }
            if (value > 0) {
                AccTimerTSec[keyAccTimers]--
            }
        }
    }
}
return

ActivateWinUM: 
;if (IsRunelite=1) {
	MouseGetPos,,, WinUMID
	WinGetTitle, TitleUnderCursor, ahk_id %WinUMID%
	wingetactivetitle, AWTitle
	if (capsWinUMSwitch=1 and (TitleUnderCursor != capsTitle)) {
		return
	} else if (capsWinUMSwitch=1 and (AWTitle != capsTitle or capsTitle = TitleUnderCursor)) {
		capsWinUMSwitch:=0
	}
	
	MouseGetPos,,,,WinCLASS
    WinGetClass, P_WinCLASS, A
if ((WinUMID!=P_WinUMID or TitleUnderCursor != AWTitle) and WinCLASS="SunAwtCanvas2" and P_WinCLASS="SunAwtFrame") {
		P_WinUMID=%WinUMID%
	WinGetTitle, titleMPOS, ahk_id %WinUMID%
		for key, value in WinDisable {
			if (value=titleMPOS) {
				ShowOsdMessage("Window Disabled", 0.5)
				return
			}
			
			;goto UpdateOSD
		;}
}
WinActivate, ahk_id %WinUMID% ; else if (WinCLASS and WinCLASS!="") {
; sleep 200
;}
gosub, UpdateOSD
}
return

AlarmSound:
alcounter+=1
if (AltAlarmSound=1){
AlarmDir=%A_WinDir%\Media\Alarm07.wav
SoundSetWaveVolume, 50
} else {
AlarmDir = %A_WinDir%\Media\Alarm10.wav
}
if (PlaySound=1) {
    SoundPlay, %AlarmDir%
} else {
    PlaySound:=2
	alcounter:=0
	SoundPlay, Nonexistent.avi
    SetTimer, AlarmSound, off    
}
if (AltAlarmSound=1 and alcounter>0){
	AltAlarmSound:=0
	alcounter:=0
	SoundSetWaveVolume, 100
	SoundPlay, Nonexistent.avi
	SetTimer, AlarmSound, off  
}
return

ChaosTimer:
for keyChaos, valChaos in ChaosWindowGUIDArray {
if (keyChaos>CounterWinBack2)
    return
if (stopToggle!=valChaos) {
if (chaosRandySkip!=1){
cRand:=Rand(3.5,4.5)
            if (ChaosX[keyChaos]>=(ChaosArray[keyChaos*6-2])-WinNameNW[keyChaos]) { 
                chaosDirection[keyChaos]:=-cRand
            } else if (ChaosX[keyChaos]<=(ChaosArray[keyChaos*6-4])) { 
                chaosDirection[keyChaos]:=cRand
            }
            if (ChaosY[keyChaos]>=(ChaosArray[keyChaos*6-1]/2)-(WinNameNH[keyChaos]/2)+245) { 
                chaosDirection2[keyChaos]:=-cRand
            } else if (ChaosY[keyChaos]<=-(ChaosArray[keyChaos*6-1]/2)+(WinNameNH[keyChaos]/2)+245) {
                chaosDirection2[keyChaos]:=cRand
            }
} else {
    chaosRandySkip:=0
}
ChaosX[keyChaos]:= chaosDirection[keyChaos] + ChaosX[keyChaos]
ChaosY[keyChaos]:= chaosDirection2[keyChaos] + ChaosY[keyChaos]
WinMove, ahk_ID %valChaos% , , % ChaosX[keyChaos] , % ChaosY[keyChaos]
}
}    
return

controller_timer:
	;3String = %cont_buttons% %cont_name% %cont_info%
	;3Time:=40*2
	;GuiConF(3,3,3String,-1)
	;sleep, 1000
	
	O_controller_out := controller_out
	controller_out := % controller_func(cont_buttons,cont_name,cont_info)
	controller_out_btn := substr(controller_out, strlen(controller_out), 1)
	;3String = %controller_out_btn% - %controller_out%
	;3Time:=40*2
	;GuiConF(3,3,3String,-1)
	if (O_controller_out != controller_out and InitFinish==1 and Controller_Window_Focus!="") {
		WinGetClass,CClass,A
		if (CClass != Controller_Window_Focus and Controller_Window_Focus != "Shell_TrayWnd"){
			;O_CClass := CClass
			WinActivate, ahk_class %Controller_Window_Focus%
			;mousegetpos, x, y
			;mousemove, x+1, y+1
			;3String = sanity
			;3Time:=40*2
			;GuiConF(3,3,3String,-1)
		}
	} else if (Controller_Window_Focus="" and InitFinish==1 and O_controller_out != controller_out) {
		ShowOsdMessage("No window set for controller focus. Use CAPS + G.", 2)
	}
	sleep, 100
	return

MsgboxMove:
    IfWinNotExist, %MsgboxMove_String%
        return 
SetTimer, MsgboxMove, off
MouseGetPos, MouseX, MouseY
MsgBoxMoveMGPX:=MouseX-20
MsgBoxMoveMGPY:=MouseY-20
WinMove, %MsgboxMove_String%, , %MsgBoxMoveMGPX%, %MsgBoxMoveMGPY%
if (ChangeBtnNames=1) {
    ChangeBtnNames:=0
    WinActivate %MsgboxMove_String%
    sleep 100
    ControlSetText, Button1, &%Btn1_Name%
    ControlSetText, Button2, &%Btn2_Name%    
}
return

Repaint:
if(!counterM2 or counterM2<0 or counterM2>=counterMM)
    counterM2:=0
counterM2++
if (hdd_frame[counterM2]="destroyed")
    return
zoom = 3
Rx3 := % ResX[counterM2]
Ry3 := % ResY[counterM2]

if (MouseFollowMag>=1 and MouseFollowMagID=CounterM2 and MouseFollowMagID) {
    MouseGetPos x2x2, y2y2
    zoom := 3
    Zx[MouseFollowMagID] := ResX[MouseFollowMagID]/zoom
    Zy[MouseFollowMagID] := ResY[MouseFollowMagID]/zoom
    if (MouseFollowMag=1) {
        x2[MouseFollowMagID] := x2x2-Zx[MouseFollowMagID]+(ResX[MouseFollowMagID]/zoom)/2
        y2[MouseFollowMagID] := y2y2-Zy[MouseFollowMagID]+(ResY[MouseFollowMagID]/zoom)
    } else if (MouseFollowMag=2) {
		;msgbox, here
        ;x2[MouseFollowMagID] := (BoredTickX+((ResX[counterM2]/zoom)/2)+42)-Zx[MouseFollowMagID]+(ResX[MouseFollowMagID]/zoom)/2
        x2[MouseFollowMagID] := (BoredTickX)-Zx[MouseFollowMagID]+(ResX[MouseFollowMagID]/zoom)/2
        ;y2[MouseFollowMagID] := (BoredTickY+((ResY[counterM2]/zoom)/2))-Zy[MouseFollowMagID]+(ResY[MouseFollowMagID]/zoom)
        y2[MouseFollowMagID] := (BoredTickY)-Zy[MouseFollowMagID]+(ResY[MouseFollowMagID]/zoom)
    }
}
xz := % x2[counterM2]-Zy[counterM2]
   yz := % y2[counterM2]-Zy[counterM2]
   DllCall("gdi32.dll\StretchBlt"
   , UInt,hdc_frame[counterM2]
   , Int,0
   , Int,0
   , Int,2*Rx3
   , Int,2*Ry3
   , UInt,hdd_frame[counterM2]
   , UInt,xz
   , UInt,yz
   , Int,2*Zx[counterM2]
   , Int,2*Zy[counterM2]
   , UInt,0xCC0020) 
Return

SaveWait:
SaveWaitCounter--
if (SaveWaitCounter<=0) {
    SetTimer, SaveWait, off
    IniWrite, %OSD_MOVE%, %ConfigPath%, OSD, X_Offset
    IniWrite, %OSD_MOVE2%, %ConfigPath%, OSD, Y_Offset
}
return

tickHUD:
if (tickLimit!=NaN and tickHUD=1) {
    tickCounter++
    TickTockTickTock++
    if (tickLimit>0 and tickCounter>tickLimit) {
        tickCounter=1
    }

        if (TickTockTickTock=1) 
            TockTockTickText=/  %tickCounter%  /    
        if (TickTockTickTock=2)
            TockTockTickText=|  %tickCounter%  |
        if (TickTockTickTock=3)
            TockTockTickText=\  %tickCounter%  \
        if (TickTockTickTock=4) {
            TockTockTickText=-- %tickCounter% --
            TickTockTickTock:=0
        }
GuiRandColor(4)
GuiConF(4, 3, TockTockTickText, -1)
} else { 
setTimer, tickHUD, off
GuiConF(4,2,-1,-1)
tickCounter:=0
}
initTick++
return

Three:
;critical
if(stopThreeGo!=1)
	MouseGetPos, ThreeX, ThreeY

	;if(GlobalMouseCounter>=1){
	;	GlobalMCX:=ThreeX+20
	;	GlobalMCY:=ThreeY+10
	;	GuiConf(3,1, GlobalMCX, GlobalMCY) 
	;}
    if (GUI2ActiveMouse=1 and GlobalTotalSeconds and TimerIsRunning=1) {
		if(stopThreeGo!=1) {
					MgetX2:=ThreeX+10
					MgetY2:=ThreeY - 7
		}					
		GuiConF(2,1, MgetX2, MgetY2) 
    } else if (!GlobalTotalSeconds) {
            GuiConF(2,2,-1,-1)
    }
;-;-;-;-;-;-;-;-;-;-;-;-;-;-;-
    if (3Time>=0 and MouseMessages!=0) {
    ;if(stopThreeGo!=1)
    ;    MouseGetPos, ThreeX, ThreeY
        
        if ((CurDisplayCY!=ThreeY and CurDisplayCX!=ThreeX)) {
			3Time--
				if(3Time>=1)
					GuiConF(3,1,ThreeX-10,ThreeY+50)
				else
					GuiConF(3,2,-1,-1)
			}

        } else {
            GuiConF(3,2,-1,-1)
        }
    
;-;-;-;-;-;-;-;-;-;-;-;-;-;-;-
if (tickHUD==1 and tickDisplaySetting==1) {
	;msgbox, here
    ;if(stopThreeGo!=1)
    ;    MouseGetPos, ThreeX, ThreeY
        if (tickDisplaySetting==1) {
			4ThreeX:=ThreeX-78
			4ThreeY:=ThreeY-50
        }
        if (initTick>=1)
            GuiConF(4,1,4ThreeX,4ThreeY)
} else if (tickDisplaySetting==2) {
        if (initTick>=1 and tickHUD=1) {
            if (boredCounter>=(CurDisplayW/2)-50) {
                boredDirection:=Rand(-1.5,-0.5)
            } else if (boredCounter<=-(CurDisplayW/2)+50) {
                boredDirection:=Rand(0.5,1.5)
            }
            if (boredCounter2>=(CurDisplayH/2)-20) {
                boredDirection2:=Rand(-1.5,-0.5)
            } else if (boredCounter2<=-(CurDisplayH/2)+15) {
                boredDirection2:=Rand(0.5,1.5)
            }
            boredCounter:=boredCounter+boredDirection*Rand(3,7)
            boredCounter2:=boredCounter2+boredDirection2
            BoredTickX:=floor((CurDisplayW/2)+boredCounter)-60+CurDisplayX
            BoredTickY:=floor((CurDisplayH/2)-boredCounter2)-25+CurDisplayY
            GuiConF(4,1,BoredTickX,BoredTickY)
        }

        if (Debug=1 and DebugPriority<=2) {
			fBC2:=floor(boredCounter2)
			fBC:=floor(boredCounter)
            fBD:=floor(boredDirection)
            fBD2:=floor(boredDirection2)
            DebugPriority:=2
            5String=X: %ThreeX% %4ThreeX% Y: %ThreeY% %4ThreeY% - B: %fBD% %fBD2% %fBC% %fBC2%
        }
} else if (tickDisplaySetting==3) {
    ThreeSinCosCounter+=10
    r:=100
    dir:=1
    4ThreeX:=(ThreeX+r*cos(((ThreeSinCosCounter-1)/(2*r*3.1416))))-73
    4ThreeY:=(ThreeY+dir*r*sin(((ThreeSinCosCounter-1)/(2*r*3.1416))))-10
    if (initTick>=1)
        GuiConF(4,1,4ThreeX,4ThreeY)

    if (Debug=1 and DebugPriority<=2) {
        DebugPriority:=2
        5String=X: %ThreeX% - %SinCosX% --- Y: %ThreeY% - %SinCosY% 
    }
}

;-;-;-;-;-;-;-;-;-;-;-;-;-;-;--;-;-
if (Debug=1) {    
    if(stopThreeGo!=1) {
        ;MouseGetPos, ThreeX, ThreeY
        5ThreeX:=ThreeX-275
        5ThreeY:=ThreeY-50
		}
        GuiConF(5,1,5ThreeX-150,5ThreeY)
}
;-;-;-;-;-;-;-;-;-;-;-;-;-;-;-;-;-
if ((GUI2ActiveMouse=0 and 3Time<0 and tickHUD=0 and Debug=0 and GlobalMouseCounter==0)) {
    SetTimer, Three, off
    return
}
return

TimersCheck:
if ((GUI2ActiveMouse!=0 or (3Time>=0) or tickHUD!=0 or Debug!=0)) {
    SetTimer, Three, on
}
if (Debug=1) {
		if (DebugPriority=3){
			DebugCycle:=0
			while (CurDisplayCY = ThreeY and CurDisplayCX = ThreeX) {
				sleep, 1250
				DebugCycle++
				if (DebugCycle = 1)
					5String=CX=%CurDisplayCX% CY=%CurDisplayCY%
				else if (DebugCycle >= 2) {
					DebugCycle:=0
					5String=3Time=%3Time% 3String=%3String%

				}
				GuiConF(5,3,5String,-1)
			}
		} else {
			if (DebugPriority<=1) {
				DebugPriority:=1
				DebugCycle++
				if (DebugCycle=1) {
					5String=%DebugCycle%: X: GUI2ActiveMouse %GUI2ActiveMouse% - 3Time %3Time% - MouseMessages %MouseMessages%
				} else if (DebugCycle>=2){
					DebugCycle:=0
					5String=%DebugCycle%: X: tickHUD %tickHUD% - Debug %Debug% - RuneLite Window Count %RuneliteWindowCount% %RuneliteDWindowCount%
				} 
			}
			if (DebugPriority=10) {
				GuiWhiteColor(5)
			} else {
				GuiRandColor(5)
			}
		GuiConF(5,3,5String,-1)
	}
}
return

UpdateOSD:
O_Title = %Title%
WinGetActiveTitle, Title
if(O_Title!=Title) {
		IsRunelite := 0
		WinMatch:=0
	if (OnTopArray[Title]=1) {
		for GuiKeyCheck, GuiValueCheck in GuiActiveArray {
			if instr(GuiKeyCheck,"Outline") { 
				Gui, %GuiKeyCheck%: +AlwaysOnTop
			}
		}
		for GuiKeyCheck, GuiValueCheck in GuiActiveArray {    
			if !instr(GuiKeyCheck,"Outline") { 
				Gui, %GuiKeyCheck%: +AlwaysOnTop
				
			}
		}
	OnTopArray[Title]:=2
	}
	 if OnTopArray[O_Title]=2 {
		OntopArray[O_Title]:=1
	}
	IsRunelite := % RegExMatch(StrReplace(Title,"Runelite - ","RLWINDOW"),"RLWINDOW(.*)")
	if (IsRunelite=1) {
		NameCheck1 := % SubStr(Title, 12)
		if !NameCheck1
			return
		NameKnown:=0
		WinChangeCounterColor:=0
		;#########
		for AccKey, AccValue in Account {
			if (NameCheck1=AccValue) {
				NameKnown:=1
				LastFocused:=Title
				WinChangeCounterColor:=AccKey
				if (CounterFuncArray[AccKey]) {
					counterkey=% CounterFuncArray[AccKey]
				} else {
					counterkey:=
				}
				WinMatch:=1
			break
		}  
	}
	if (NameKnown!=1) {      
        ; New account found, add it and save to INI
        Account.Insert(NameCheck1)
        NumAccs++
        AccountIndex := % Account.MaxIndex()-1
        
        ; Rebuild the account list string for INI
        KnownAccounts := ""
        For key, val in Account
            KnownAccounts .= val "|"
        IniWrite, %KnownAccounts%, %ConfigPath%, Accounts, List
        return
	}
	While (WinChangeCounterColor>6) {
					WinChangeCounterColor:=WinChangeCounterColor-6
				}
				if (WinChangeCounterColor=1) {
					AccColorWinChange=White
				} else if (WinChangeCounterColor=2) {
					AccColorWinChange=Lime
				} else if (WinChangeCounterColor=3) {
					AccColorWinChange=7fe5f0 
				} else if (WinChangeCounterColor=4) {
					AccColorWinChange=Red
				} else if (WinChangeCounterColor=5) {
					AccColorWinChange=8470FF
				} else if (WinChangeCounterColor=6){
					AccColorWinChange=Yellow 
				} 
					StringReplace, NTitle, Title, RuneLite -, , All        ;;; ---- This allows for the OSD to remain drawn when focusing other windows
					

					Gui, 1: Default
					GuiControl, +c%AccColorWinChange%, MyText
					GuiConF(1,3,NTitle,-1)
	}
}

if (WinMatch=1 and IsRunelite=1) {     ;;; ----- Added so that when non-runelite window is focused this data data for active window does not update
    
    WinGetActiveStats, Title, wWidth, wHeight, WX, WY
    WY+=OSD_MOVE2+50
    WX+=OSD_MOVE+10
    if (counterkey>0)
        NTitle = %NTitle% - %counterkey%
    if(GUI_Names=1)
        GuiConF(1,1,WX,WY)
    
} else {
	GuiConF(1,2,-1,-1)
}
    if ((TimerIsRunning=1 or TimerIsPaused=1) and (TimerMouseT=1 or TimerMouseT=0)) { 
        GUI2ActiveMouse:=1
    } else {
            GuiConF(2,2,-1,-1)
            GUI2ActiveMouse:=0
    }
        
    return

UpdateOSD2:
    if(TimerIsPaused=1) {
        GuiConF(2,2,-1,-1)
        return
    }
    Gui, 2: Default
    
    ; First, check the state of the timer and prepare the display string
    if (GlobalSecondsDisplayInit >= 0) {
        ; Timer is running or is at 0:00, so we format the time
        SetTimer, UpdateOSD2, 1000 ; Ensure timer is at a 1-second interval
        
        Gui2Color = % RandColor()
        GuiControl, +c%Gui2Color%, MyText

        GlobalTimerMinR := Floor(GlobalSecondsDisplayInit / 60)
        LocalSecondDisplay := Mod(GlobalSecondsDisplayInit, 60)

        if (LocalSecondDisplay < 10) {
            TimerTimeStr := GlobalTimerMinR ":0" LocalSecondDisplay
        } else {
            TimerTimeStr := GlobalTimerMinR ":" LocalSecondDisplay
        }
    } else {
        ; Timer has finished (GlobalSecondsDisplayInit is < 0)
        TimerTimeStr := "TIME"
        SetTimer, UpdateOSD2, 150 ; Speed up for flashing text

        if (colorswap = 0) {
            colorswap := 1
            if (PlaySound = 0) { ; Start the alarm only once
                PlaySound := 1
                SetTimer, AlarmSound, 4000
                SetTimer, AlarmSound, on
            }
            GuiControl, +cRED, MyText
        } else {
            colorswap := 0
            GuiControl, +cWHITE, MyText
        }
    }
    
    ; Now, update the GUI with the prepared string
    GuiConF(2,3,TimerTimeStr,-1)

    ; Finally, decrement the counter for the next tick AFTER the current value has been displayed.
    GlobalSecondsDisplayInit--
return

#If ; End of Timers section


;#######################################################################################################################
;#######################################################################################################################
;
;   SECTION 6: FUNCTIONS
;
;#######################################################################################################################
;#######################################################################################################################

;=================================================
;   GUI Functions
;=================================================
ShowOsdMessage(Text, Seconds) {
    Global 3Time, 3String
    3String := Text
    3Time := Seconds * 40 ; 40 ticks = 1 second
    GuiConF(3, 3, 3String, -1)
}

BuildGUI(GuiNumber) {
global GuiActiveArray
global WaitJustOneFuckingSecond
if (GuiNumber!=0 and GuiNumber) {
    CustomColor = 000000 ;
    Gui, %GuiNumber%: Destroy
    Gui, %GuiNumber%: New, +LastFound -Caption +ToolWindow +AlwaysOnTop +E0x20
    Gui, %GuiNumber%: Color, 000000
    if (GuiNumber=1) {
        Gui, %GuiNumber%: Font, s18, Magneto ; Matura MT Script Capitals ; DejaVu Sans
        Gui, %GuiNumber%: Add, Text, vMyText +cWhite, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    } else if (GuiNumber=3 or GuiNumber=5) {
        Gui, %GuiNumber%: Font, s11, OCR A Std ; Fixedsys ; DejaVu Sans
        Gui, %GuiNumber%: Add, Text, vMyText +cWhite, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    } else if (Substr(GuiNumber,1,1)="_") { ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
        Gui, %GuiNumber%: Font, s56 ; Mistral ; Franklin Gothic Book ;Corbel
        Gui, %GuiNumber%: Add, Text, vMyText +cblack, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        GuiActiveArray[GuiNumber]:=2 ; set to dot id on active array to 2 for removal later
        WinSet, TransColor, %CustomColor% 255
        return
    } else if (Substr(GuiNumber,1,4)="Note") { ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
        Gui, %GuiNumber%: Font, s14, OCR A Std ; Mistral ; Franklin Gothic Book ;Corbel
        Gui, %GuiNumber%: Add, Text, vMyText +cblack, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        GuiActiveArray[GuiNumber]:=3 ; set to dot id on active array to 2 for removal later
        WinSet, TransColor, %CustomColor% 255
        return
    } else if (Substr(GuiNumber,1,4)="Temp") { ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
        Gui, %GuiNumber%: Font, s36, OCR A Std ; Mistral ; Franklin Gothic Book ;Corbel
        Gui, %GuiNumber%: Add, Text, vMyText +cblack, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        GuiActiveArray[GuiNumber]:=4 ; for dots when 2 then remove , then set to 0 , it is how they are identified during this process
        WinSet, TransColor, %CustomColor% 255
        return
        } else {
        Gui, %GuiNumber%: Font, s14, OCR A Std ; Mistral ; Franklin Gothic Book ;Corbel
        Gui, %GuiNumber%: Add, Text, vMyText +cblack, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        ;return
    }
WinSet, TransColor, %CustomColor% 255
GuiActiveArray[GuiNumber]:=1
    if (GuiNumber>NumAccs and InitFinish!=1) {
        Gui, %GuiNumber%: Hide       
    }
WaitJustOneFuckingSecond=2
SetTimer, 1fuckingsecondtimer, on
}
return
}

OutlineBuilder(GuiNumber) {
global GuiActiveArray
OutlineBuilder:
CustomColor2 = 0B0D0F ;
OutlineCounter:=0
While (OutlineCounter<4) {
OutlineCounter++
GuiOutlineID=%GuiNumber%Outline%OutlineCounter%
GuiActiveArray[GuiOutlineID]:=1
if (Substr(GuiOutlineID,1,1)=Chr(8226)) ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
    GuiActiveArray[GuiOutlineID]:=2 ; for dots when 2 then remove , then set to 0 , it is how they are identified during this process
if (Substr(GuiOutlineID,1,4)="Temp") ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
    GuiActiveArray[GuiOutlineID]:=4 ; for dots when 2 then remove , then set to 0 , it is how they are identified during this process

Gui, %GuiOutlineID%: Default
Gui, %GuiOutlineID%: Destroy
Gui, %GuiOutlineID%: New, +LastFound -Caption +ToolWindow +AlwaysOnTop +E0x20
Gui, %GuiOutlineID%: Color, %CustomColor2%
if (GuiNumber=3 or GuiNUmber=5) {
Gui, %GuiOutlineID%: Font, Bold s11, OCR A Std ; Fixedsys ; DejaVu Sans
Gui, %GuiOutlineID%: Add, Text, vMyText +c0A0F0A, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
} else if (GuiNumber=1) {
Gui, %GuiOutlineID%: Font, s18, Magneto
Gui, %GuiOutlineID%: Add, Text, vMyText +c0A0F0A, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
} else if(Substr(GuiOutlineID,1,4)="Temp")  {
Gui, %GuiOutlineID%: Font, s36, OCR A Std ; Fixedsys ; DejaVu Sans
Gui, %GuiOutlineID%: Add, Text, vMyText +c0B0D0F, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
} else if(Substr(GuiOutlineID,1,1)="_")  {
Gui, %GuiOutlineID%: Default
Gui, %GuiOutlineID%: Font, s8 ; Fixedsys ; DejaVu Sans
Gui, %GuiOutlineID%: Add, Text, vMyText +c0B0D0F, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
WinSet, TransColor, %CustomColor2% 255
GuiControl, +c0A0B0C, MyText
    return
} else if(Substr(GuiOutlineID,1,1)=Chr(8226) or Substr(GuiOutlineID,1,1)="X")  { ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
Gui, %GuiOutlineID%: Default
Gui, %GuiOutlineID%: Font, s57 ; Fixedsys ; DejaVu Sans
Gui, %GuiOutlineID%: Add, Text, vMyText +c0B0D0F, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
WinSet, TransColor, %CustomColor2% 255
GuiControl, +c0A0B0C, MyText
    return
} else  {

Gui, %GuiOutlineID%: Font, Bold s14, OCR A Std ; Fixedsys ; DejaVu Sans
Gui, %GuiOutlineID%: Add, Text, vMyText +c0B0D0F, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
}
WinSet, TransColor, %CustomColor2% 255
GuiControl, +c0A0B0C, MyText
}
return
}

GuiConF(GuiVar,ConType,xLoc,yLoc) {
Global NumAccs
Global DotCounter
    if (GuiVar and xLoc and yLoc) { 
        if (ConType=1) {
            xFLoc1:=xLoc+2
            xFLoc2:=xLoc-2
            yFLoc1:=yLoc+2
            yFLoc2:=yLoc-2
            if (SubStr(GuiVar,1,1)!=Chr(8226) and SubStr(GuiVar,1,1)!="X") ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
                Gui, %GuiVar%: Show, x%xLoc% y%yLoc% NoActivate
            GuiVarCounter:=0
            
            while (GuiVarCounter<=4) {
                GuiVarCounter++            
                
                                ;Shift bottom Left
                if (GuiVarCounter=2 and SubStr(GuiVar,1,1)!="_") { ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
                    Gui, %GuiVar%Outline%GuiVarCounter%: Show, x%xFLoc1% y%yFLoc2% NoActivate
                }
                    ;shift top left
                    if (GuiVarCounter=3 and SubStr(GuiVar,1,1)!="_") { ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
                        Gui, %GuiVar%Outline%GuiVarCounter%: Show, x%xFLoc2% y%yFLoc1% NoActivate
                    }
                if (GuiVar!=1) {
                    ;Shift Top Right
                if (GuiVarCounter=1) {
                        
                        if (SubStr(GuiVar,1,1)="_") { ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
                        ;msgbox, % xFLoc3
                            xFLoc1 := xFLoc1+61
                        if (DotCounter<100)
                            xFLoc1 := xFLoc1+4
                        if (DotCounter<10)
                            xFLoc1 := xFLoc1+4
                        yFLoc1 := yFLoc1+70
                            Gui, %GuiVar%Outline%GuiVarCounter%: Show, x%xFLoc1% y%yFLoc1% NoActivate
                    return
                    } else if (SubStr(GuiVar,1,1)=Chr(8226) or SubStr(GuiVar,1,1)="X") { ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
                        Gui, %GuiVar%Outline1: Default
            GuiControl,, MyText, % Chr(8226)
            Gui, %GuiVar%Outline%GuiVarCounter%: Show, x%xFLoc1% y%yFLoc1% NoActivate
            return
                        } 
                    Gui, %GuiVar%Outline%GuiVarCounter%: Show, x%xFLoc1% y%yFLoc1% NoActivate
                    }
                ;Shift Bottom Right
                    if (GuiVarCounter=4 and SubStr(GuiVar,1,1)!="_") { ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
                        Gui, %GuiVar%Outline%GuiVarCounter%: Show, x%xFLoc2% y%yFLoc2% NoActivate
                    }
                }
            }
        } else if (ConType=2) {

            Gui, %GuiVar%: Hide
        if (SubStr(GuiVar,1,1)=Chr(8226) or SubStr(GuiVar,1,1)="X") ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
            return
            if (SubStr(GuiVar,1,1)="_") { ; For Dots outlines they have less GUI, only 1 outline, 1 text, 1 dot, built seperately.
                Gui, %GuiVar%Outline1: Hide
                return
            }
            GuiVarCounter:=0
            while (GuiVarCounter<=4) {
                GuiVarCounter++
                Gui, %GuiVar%Outline%GuiVarCounter%: Hide
            }
        } else if (ConType=3) {

            Gui, %GuiVar%: Default
            GuiControl,, MyText, %xLoc%
            if (SubStr(GuiVar,1,1)="_") {            
                        DotCounter++
                        Gui, %GuiVar%Outline1: Default
                        GuiControl,, MyText, %DotCounter%
            return
            }
            GuiVarCounter:=0
            while (GuiVarCounter<=4) {
                GuiVarCounter++
                Gui, %GuiVar%Outline%GuiVarCounter% : Default
                GuiControl,, MyText, %xLoc%
            }
        } else if (ConType=4) {
            GuiVarCounter:=0
            while (GuiVarCounter<=4) {
            GuiVarCounter++
                if (xLoc=1) {
                Gui, %GuiVar%Outline%GuiVarCounter% : +AlwaysOnTop
                    if (GuivarCounter=4)
                        Gui, %GuiVar%: +AlwaysOnTop
                    
                } else if (xLoc=0) {
                Gui, %GuiVar%Outline%GuiVarCounter% : -AlwaysOnTop
                    if (GuivarCounter=4)
                        Gui, %GuiVar%: -AlwaysOnTop

                }
            }
        }
    }
    return
}

;=================================================
;   Timer Functions
;=================================================
StartGlobalTimer() {
    global GlobalTimerMinutes, GlobalTotalSeconds, GlobalSecondsDisplayInit
    global TimerIsRunning, TimerIsPaused, TimerResetWarning, PlaySound

    if (!GlobalTimerMinutes or GlobalTimerMinutes <= 0) {
        ; This shouldn't be hit if called from SetGlobalTimerMinutes, but good failsafe
        return
    }
    
    GlobalTotalSeconds := GlobalTimerMinutes * 60
    GlobalSecondsDisplayInit := floor(GlobalTotalSeconds)
    
    TimerIsRunning:=1
    TimerIsPaused:=0
    TimerResetWarning:=0
    PlaySound:=0
    
    ShowOsdMessage("A New timer has started", 1)

    ; Immediately show the initial state
    GoSub, UpdateOSD2 
    
    SetTimer, UpdateOSD2, 1000
}

SetGlobalTimerMinutes() {
    global GlobalTimerMinutes, GlobalTotalSeconds, ConfigPath, GlobalSecondsDisplayInit
    global TimerTimeStr, GlobalSecondDisplay, TimerIsRunning, TimerIsPaused, CapsTAccTimersCounter
    
    if (GlobalSecondsDisplayInit<=0 or TimerTimeStr="TIME") {
        SetTimer, UpdateOSD2, off
        GlobalSecondDisplay:=60
        MouseGetPos, MgetX, MgetY
        MgetX2:=MgetX+10
        MgetY2:=MgetY+10
        InputBox, GlobalTimerMinutes_input, Countdown Timer, number of minutes., , 200, 125, MgetX2, MgetY2
        GlobalTimerMinutes := % GlobalTimerMinutes_input
            If (!GlobalTimerMinutes) {
                ShowOsdMessage("No Time was entered returning.", 1)
                CapsTAccTimersCounter:=0
                return false ; <-- NEW: Return false
            }
        IniWrite, %GlobalTimerMinutes%, %ConfigPath%, Timers, GlobalMinutes
        if (TimerIsRunning=1 or TimerIsPaused=1)
            ClearGlobalTimer()
        ; Goto, timer_t ; <-- REMOVED
        return true ; <-- NEW: Return true
    } else {
        ShowOsdMessage("Timer Running - Caps+Q to Reset", 1)
        return false ; <-- NEW: Return false
    }
}

ClearGlobalTimer() {
    global PlaySound, TimerIsRunning, TimerIsPaused, TimerResetWarning, GlobalSecondsDisplayInit
    global GlobalSecondsInitMin, GlobalTimerMinR, GlobalSecondDisplay, WaitJustOneFuckingSecond, ConfigPath
    
    PlaySound:=2
    SetTimer, AlarmSound, off
    SetTimer, UpdateOSD2, off
    TimerIsRunning:=0
    TimerIsPaused:=0
    TimerResetWarning=0
    GlobalSecondsDisplayInit:=0
    GlobalSecondsInitMin:=
    GlobalTimerMinR:=
    GlobalSecondDisplay:=
    
    IniDelete, %ConfigPath%, Timers, Paused
    IniDelete, %ConfigPath%, Timers, PausedMinutes
    IniDelete, %ConfigPath%, Timers, PausedSeconds
        
    GuiConF(2,2,-1,-1)    
    WaitJustOneFuckingSecond=3
    SetTimer, 1fuckingsecondtimer, on
    ShowOsdMessage("Timer Cleared!", 1)
    WaitJustOneFuckingSecond=0                
}

Timer_Load_Error() {
    global TimerIsRunning, TimerIsPaused, TimerResetWarning, GlobalSecondsDisplayInit
    global GlobalTotalSeconds, GlobalSecondsInitMin, GlobalTimerMinR, GlobalSecondDisplay
    
    ShowOsdMessage("Error loading any previous timer.", 1)
    IniDelete, %ConfigPath%, Timers, Paused
    IniDelete, %ConfigPath%, Timers, PausedMinutes
    IniDelete, %ConfigPath%, Timers, PausedSeconds
    SetTimer, UpdateOSD2, off
    TimerIsRunning:=0
    TimerIsPaused:=0
    TimerResetWarning=0
    GlobalSecondsDisplayInit:=GlobalTotalSeconds
    GlobalSecondsInitMin:=
    GlobalTimerMinR:=
    GlobalSecondDisplay:=60
}

;=================================================
;   Controller Functions
;=================================================
controllerCheck() {
    global ControllerNumber, InitFinish, controller_check_var
    ControllerNumber:=0
    if ControllerNumber <= 0
    {
        Loop 16  ; Query each controller number to find out which ones exist.
        {
            GetKeyState, ContName, %A_Index%JoyName
            if ContName <>
            {
                ControllerNumber = %A_Index%
                ;if (InitFinish != 1) {
                ;	SplashTextOn ,200 ,25 , Controller Info,ControllerNumber = %A_Index%
                ;}
                break
            }
        }
        if ControllerNumber <= 0
        {
            if (InitFinish != 1) {
                ;SplashTextOn ,200 ,25 , Controller Info, No controller detected
            } else {
                ShowOsdMessage("No controller found!", 1)
                controller_check_var:=2
            }
        }
    }
}

controller_func(cont_buttons,cont_name,cont_info){
	buttons_down =
	Loop, %cont_buttons%
	{
		GetKeyState, Cont%A_Index%, %ControllerNumber%Joy%A_Index%
		if Cont%A_Index% = D
			buttons_down = %buttons_down%%A_Space%%A_Index%
	}
	GetKeyState, ContX, %ControllerNumber%JoyX
	ContX:=round(ContX,0)
	axis_info = X%ContX%
	GetKeyState, ContY, %ControllerNumber%JoyY
	ContY:=round(ContY,0)
	axis_info = %axis_info%%A_Space%%A_Space%Y%ContY%
	IfInString, cont_info, Z
	{
		GetKeyState, ContZ, %ControllerNumber%JoyZ
		ContZ:=round(ContZ,0)
		axis_info = %axis_info%%A_Space%%A_Space%Z%ContZ%
	}
	IfInString, cont_info, R
	{
		GetKeyState, ContR, %ControllerNumber%JoyR
		ContR:=round(ContR,0)
		axis_info = %axis_info%%A_Space%%A_Space%R%ContR%
	}
	IfInString, cont_info, U
	{
		GetKeyState, ContU, %ControllerNumber%JoyU
		ContU:=round(ContU,0)
		axis_info = %axis_info%%A_Space%%A_Space%U%ContU%
	}
	IfInString, cont_info, V
	{
		GetKeyState, ContV, %ControllerNumber%JoyV
		ContV:=round(ContV,0)
		axis_info = %axis_info%%A_Space%%A_Space%V%ContV%
	}
	IfInString, cont_info, P
	{
		GetKeyState, ContPOV, %ControllerNumber%JoyPOV
		ContPOV:=round(ContPOV,0)
		axis_info = %axis_info%%A_Space%%A_Space%POV%ContPOV%
	}
	;GuiControl,, Edit1, %cont_name% (#%ControllerNumber%):`n%axis_info%`nButtons Down: %buttons_down%
	out = %cont_name% %ControllerNumber% %axis_info% - %buttons_down%
	;3String = %cont_name% %ControllerNumber% %axis_info% - %buttons_down%
	;3Time:=40*2
	;GuiConF(3,3,3String,-1)
	;msgbox, %cont_name% %ControllerNumber% %axis_info% %buttons_down%
return out
}

;=================================================
;   Window & System Functions
;=================================================
isRuneliteRunning() {
return WinExist("ahk_exe Runelite.exe")
}

isRuneliteActive() {
return WinActive("ahk_exe Runelite.exe")
}

monitorFunc() { 
MonArray:=Array()
    CoordMode, Mouse, Screen
        MouseGetPos, NoX, NoY
        SysGet, monCount, MonitorCount
        Loop %monCount%
        {     
        SysGet, curMon, Monitor, %a_index%
            if ( NoX >= curMonLeft and NoX <= curMonRight and NoY >= curMonTop and NoY <= curMonBottom )
                {
                    TDISPLAYY      := curMonTop ; can't be less than
                    TDISPLAYX      := curMonLeft ; can't be less than
                    TDISPLAYY2        := curMonBottom ; can't be greater
                    TDISPLAYX2        := curMonRight ; can't be greater
                    TDISPLAYHeight := curMonBottom - curMonTop
                    TDISPLAYWidth  := curMonRight  - curMonLeft
                    
MonArray := [TDISPLAYY,TDISPLAYX,TDISPLAYY2,TDISPLAYX2,TDISPLAYHeight,TDISPLAYWidth]
            }
        }

return MonArray
}

;=================================================
;   Utility Functions (Rand, Color, etc)
;=================================================
Rand( a=0.0, b=1 ) {
   IfEqual,a,,Random,,% r := b = 1 ? Rand(0,0xFFFFFFFF) : b
   Else Random,r,a,b
   Return r
}

RandColor() {
    Random, vRand, 0x4FFFFF, 0xAFFFFF
    color = % Format("{:06X}", vRand)
return color
}

RandColor2() {
    ;Random, vRand, 0, 0xFFFFFF
    Random, vRand, 0x4FFFFF, 0xAFFFFF
    color = % Format("{:06X}", vRand)
return color
}

GuiSpecificColor(GuiNumber,color) {
	if (GuiNumber) {
		Gui, %GuiNumber%: Default
		GuiControl, +c%color%, MyText
	}
	return
}

GuiRandColor(GuiNumber) {
	if (GuiNumber) {
		Gui, %GuiNumber%: Default
		Random, vRand, 0x33DE10, 0x33DF10
		color = % Format("{:06X}", vRand)
		GuiControl, +c%color%, MyText
	}
	return
}

GuiWhiteColor(GuiNumber) {
if (GuiNumber) {
    Gui, %GuiNumber%: Default
    GuiControl, +cWhite, MyText
}
    return
}

RandomStr(l = 16, i = 48, x = 122) { ; length, lowest and highest Asc value
    Loop, %l% {
        Random, r, i, x
        s .= Chr(r)
    }
    Return, s
}
